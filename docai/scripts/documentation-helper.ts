/**
 * Helper functions for the documentation generation process
 * These functions support the main documentation generation process
 * with better error handling, logging, and file management
 */

import { promises as fs } from "fs";
import path from "path";

// Tracks progress of documentation generation for logging and summary
interface DocumentationProgress {
  startTime: Date;
  endTime?: Date;
  sections: {
    name: string;
    status: "pending" | "success" | "error";
    startTime?: Date;
    endTime?: Date;
    error?: string;
  }[];
}

/**
 * Creates and initializes a documentation file with header and table of contents
 */
export const initializeDocumentationFile = async (
  filePath: string,
  projectName: string,
  sections: { name: string; anchor: string }[]
): Promise<void> => {
  const lastupdate = new Date().toLocaleString();

  // Create table of contents from sections
  const tableOfContents = sections
    .map(
      (section, index) => `${index + 1}. [${section.name}](#${section.anchor})`
    )
    .join("\n");

  const initialContent =
    `# ${projectName} Documentation\n\n` +
    `*Last Updated: ${lastupdate}*\n\n` +
    `## Table of Contents\n\n${tableOfContents}\n\n` +
    `---\n\n`;

  try {
    // Create directory if it doesn't exist
    const directory = path.dirname(filePath);
    await fs.mkdir(directory, { recursive: true });

    // Write initial content
    await fs.writeFile(filePath, initialContent, "utf-8");
    console.log(`Documentation file initialized at ${filePath}`);
  } catch (error: any) {
    console.error(`Failed to initialize documentation file: ${error.message}`);
    throw new Error(`Documentation initialization failed: ${error.message}`);
  }
};

/**
 * Creates a progress tracker for documentation generation
 */
export const createProgressTracker = (
  sections: string[]
): DocumentationProgress => {
  return {
    startTime: new Date(),
    sections: sections.map((name) => ({
      name,
      status: "pending",
    })),
  };
};

/**
 * Updates the progress tracker when a section starts
 */
export const markSectionStarted = (
  progress: DocumentationProgress,
  sectionName: string
): DocumentationProgress => {
  const updatedSections = progress.sections.map((section) => {
    if (section.name === sectionName) {
      return {
        ...section,
        status: "pending" as "pending",
        startTime: new Date(),
      };
    }
    return section;
  });

  return {
    ...progress,
    sections: updatedSections,
  };
};

/**
 * Updates the progress tracker when a section completes
 */
export const markSectionCompleted = (
  progress: DocumentationProgress,
  sectionName: string,
  success: boolean,
  error?: string
): DocumentationProgress => {
  const updatedSections = progress.sections.map((section) => {
    if (section.name === sectionName) {
      return {
        ...section,
        status: success ? "success" : "error" as "success" | "error",
        endTime: new Date(),
        error: error,
      };
    }
    return section;
  });

  return {
    ...progress,
    sections: updatedSections,
  };
};

/**
 * Finalizes the progress tracker when documentation generation completes
 */
export const finalizeProgress = (
  progress: DocumentationProgress
): DocumentationProgress => {
  return {
    ...progress,
    endTime: new Date(),
  };
};

/**
 * Writes a summary of the documentation generation to the documentation file
 */
export const writeDocumentationSummary = async (
  filePath: string,
  projectName: string,
  progress: DocumentationProgress
): Promise<void> => {
  const startTime = progress.startTime;
  const endTime = progress.endTime || new Date();
  const duration = (endTime.getTime() - startTime.getTime()) / 1000; // in seconds

  const successCount = progress.sections.filter(
    (s) => s.status === "success"
  ).length;
  const errorCount = progress.sections.filter(
    (s) => s.status === "error"
  ).length;

  const summaryContent =
    `\n\n## Documentation Generation Summary\n\n` +
    `This documentation was automatically generated on ${endTime.toLocaleString()}.\n\n` +
    `* **Project Name**: ${projectName}\n` +
    `* **Generation Duration**: ${Math.round(duration)} seconds\n` +
    `* **Successful Sections**: ${successCount} of ${progress.sections.length}\n` +
    `* **Failed Sections**: ${errorCount}\n\n`;

  // Add section on errors if any occurred
  const errorContent =
    errorCount > 0
      ? `### Sections with Errors\n\n` +
      progress.sections
        .filter((s) => s.status === "error")
        .map((s) => `* **${s.name}**: ${s.error || "Unknown error"}`)
        .join("\n") +
      "\n\n"
      : "";

  // Add footer
  const footer =
    `---\n\n` +
    `*Documentation generated by Next.js Documentation Generator*\n`;

  try {
    await appendToFile(filePath, summaryContent + errorContent + footer);
  } catch (error: any) {
    console.error(`Failed to write documentation summary: ${error.message}`);
  }
};

/**
 * Safely appends content to a file with error handling
 */
export const appendToFile = async (
  filePath: string,
  content: string
): Promise<void> => {
  try {
    await fs.appendFile(filePath, content, "utf-8");
  } catch (error: any) {
    console.error(`Failed to append to file: ${error.message}`);
    throw new Error(`Failed to write to documentation file: ${error.message}`);
  }
};

/**
 * Formats a section heading for documentation
 */
export const formatSectionHeading = (
  sectionName: string,
  level: number = 2
): string => {
  const heading = "#".repeat(level);
  return `\n\n${heading} ${sectionName}\n\n`;
};

/**
 * Runs a documentation agent with standardized error handling and progress tracking
 */
export const runDocumentationAgent = async (
  agent: Function,
  sectionName: string,
  progress: DocumentationProgress,
  params: any
): Promise<DocumentationProgress> => {
  // Update progress to mark section as started
  let updatedProgress = markSectionStarted(progress, sectionName);

  try {
    console.log(`⏳ Generating ${sectionName} documentation...`);

    // Run the agent
    await agent(params);

    console.log(`✅ ${sectionName} documentation completed successfully`);

    // Update progress to mark section as completed successfully
    updatedProgress = markSectionCompleted(updatedProgress, sectionName, true);
  } catch (error: any) {
    console.error(`❌ Error generating ${sectionName} documentation:`, error);

    // Try to append error notice to the documentation file
    try {
      await appendToFile(
        params.outputPath,
        formatSectionHeading(sectionName) +
        `> ⚠️ **Error**: Documentation for this section could not be generated.\n\n` +
        `> ${error.message || "An unknown error occurred."}\n\n`
      );
    } catch (appendError) {
      console.error(`Failed to append error notice: ${appendError}`);
    }

    // Update progress to mark section as failed
    updatedProgress = markSectionCompleted(
      updatedProgress,
      sectionName,
      false,
      error.message || "Unknown error"
    );
  }

  return updatedProgress;
};
