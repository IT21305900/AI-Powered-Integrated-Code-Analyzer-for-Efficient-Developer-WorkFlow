"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-git";
exports.ids = ["vendor-chunks/simple-git"];
exports.modules = {

/***/ "(rsc)/./node_modules/simple-git/dist/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/simple-git/dist/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckRepoActions: () => (/* binding */ CheckRepoActions),\n/* harmony export */   CleanOptions: () => (/* binding */ CleanOptions),\n/* harmony export */   DiffNameStatus: () => (/* binding */ DiffNameStatus),\n/* harmony export */   GitConfigScope: () => (/* binding */ GitConfigScope),\n/* harmony export */   GitConstructError: () => (/* binding */ GitConstructError),\n/* harmony export */   GitError: () => (/* binding */ GitError),\n/* harmony export */   GitPluginError: () => (/* binding */ GitPluginError),\n/* harmony export */   GitResponseError: () => (/* binding */ GitResponseError),\n/* harmony export */   ResetMode: () => (/* binding */ ResetMode),\n/* harmony export */   TaskConfigurationError: () => (/* binding */ TaskConfigurationError),\n/* harmony export */   \"default\": () => (/* binding */ esm_default),\n/* harmony export */   gitP: () => (/* binding */ gitP),\n/* harmony export */   grepQueryBuilder: () => (/* binding */ grepQueryBuilder),\n/* harmony export */   pathspec: () => (/* binding */ pathspec),\n/* harmony export */   simpleGit: () => (/* binding */ simpleGit)\n/* harmony export */ });\n/* harmony import */ var _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kwsites/file-exists */ \"(rsc)/./node_modules/@kwsites/file-exists/dist/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var _kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kwsites/promise-deferred */ \"(rsc)/./node_modules/@kwsites/promise-deferred/dist/index.js\");\n/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:events */ \"node:events\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/lib/args/pathspec.ts\nfunction pathspec(...paths) {\n  const key = new String(paths);\n  cache.set(key, paths);\n  return key;\n}\nfunction isPathSpec(path) {\n  return path instanceof String && cache.has(path);\n}\nfunction toPaths(pathSpec) {\n  return cache.get(pathSpec) || [];\n}\nvar cache;\nvar init_pathspec = __esm({\n  \"src/lib/args/pathspec.ts\"() {\n    \"use strict\";\n    cache = /* @__PURE__ */ new WeakMap();\n  }\n});\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    \"use strict\";\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\n\nfunction asFunction(source) {\n  return typeof source === \"function\" ? source : NOOP;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return !!(input && typeof input.length === \"number\");\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map((line) => callback(line));\n}\nfunction folderExists(path) {\n  return (0,_kwsites_file_exists__WEBPACK_IMPORTED_MODULE_0__.exists)(path, _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_0__.FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asCamelCase(str) {\n  return str.replace(/[\\s-]+(.)/g, (_all, chr) => {\n    return chr.toUpperCase();\n  });\n}\nfunction asStringArray(source) {\n  return asArray(source).map(String);\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? Buffer.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  return Object.assign(\n    {},\n    ...properties.map((property) => property in source ? { [property]: source[property] } : {})\n  );\n}\nfunction delay(duration = 0) {\n  return new Promise((done) => setTimeout(done, duration));\n}\nfunction orVoid(input) {\n  if (input === false) {\n    return void 0;\n  }\n  return input;\n}\nvar NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    \"use strict\";\n    NULL = \"\\0\";\n    NOOP = () => {\n    };\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  const type = isPathSpec(input) ? \"string\" : typeof input;\n  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterString, filterStringArray, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    \"use strict\";\n    init_util();\n    init_pathspec();\n    filterArray = (input) => {\n      return Array.isArray(input);\n    };\n    filterString = (input) => {\n      return typeof input === \"string\";\n    };\n    filterStringArray = (input) => {\n      return Array.isArray(input) && input.every(filterString);\n    };\n    filterStringOrStringArray = (input) => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = (input) => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return Array.isArray(input) || typeof input === \"string\" || typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    \"use strict\";\n    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    \"use strict\";\n    GitOutputStreams = class {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    \"use strict\";\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      useMatches(target, match) {\n        throw new Error(`LineParser:useMatches not implemented`);\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(\n    __spreadValues({ baseDir }, defaultOptions),\n    ...options.filter((o) => typeof o === \"object\" && o)\n  );\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    \"use strict\";\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (isPathSpec(value)) {\n      commands2.push(value);\n    } else if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_util();\n    init_pathspec();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser4, streams) {\n  return parser4(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach((text) => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({ parse }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    \"use strict\";\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asCamelCase: () => asCamelCase,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringArray: () => filterStringArray,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  orVoid: () => orVoid,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    \"use strict\";\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({ exitCode }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = (text) => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach((line) => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser4) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser4\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    \"use strict\";\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const { cleanMode, options, valid } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = { cleanMode: false, options: true };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach((char) => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    \"use strict\";\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */ new Set([\n      \"i\",\n      ...asStringArray(Object.values(CleanOptions))\n    ]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */ new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max; ) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield { file, key, value };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    \"use strict\";\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */ Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!values.hasOwnProperty(key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && GitConfigScope.hasOwnProperty(scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(\n        addConfigTask(\n          key,\n          value,\n          rest[0] === true,\n          asConfigScope(rest[1], \"local\" /* local */)\n        ),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    getConfig(key, scope) {\n      return this._runTask(\n        getConfigTask(key, asConfigScope(scope, void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    listConfig(...rest) {\n      return this._runTask(\n        listConfigTask(asConfigScope(rest[0], void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    \"use strict\";\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/diff-name-status.ts\nfunction isDiffNameStatus(input) {\n  return diffNameStatus.has(input);\n}\nvar DiffNameStatus, diffNameStatus;\nvar init_diff_name_status = __esm({\n  \"src/lib/tasks/diff-name-status.ts\"() {\n    \"use strict\";\n    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {\n      DiffNameStatus2[\"ADDED\"] = \"A\";\n      DiffNameStatus2[\"COPIED\"] = \"C\";\n      DiffNameStatus2[\"DELETED\"] = \"D\";\n      DiffNameStatus2[\"MODIFIED\"] = \"M\";\n      DiffNameStatus2[\"RENAMED\"] = \"R\";\n      DiffNameStatus2[\"CHANGED\"] = \"T\";\n      DiffNameStatus2[\"UNMERGED\"] = \"U\";\n      DiffNameStatus2[\"UNKNOWN\"] = \"X\";\n      DiffNameStatus2[\"BROKEN\"] = \"B\";\n      return DiffNameStatus2;\n    })(DiffNameStatus || {});\n    diffNameStatus = new Set(Object.values(DiffNameStatus));\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */ new Set();\n  const results = {};\n  forEachLineWithContent(grep, (input) => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(\n            configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n            then\n          );\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask(\n        {\n          commands,\n          format: \"utf-8\",\n          parser(stdOut) {\n            return parseGrep(stdOut);\n          }\n        },\n        then\n      );\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return ResetModes.includes(mode);\n}\nvar ResetMode, ResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    \"use strict\";\n    init_task();\n    ResetMode = /* @__PURE__ */ ((ResetMode2) => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    ResetModes = Array.from(Object.values(ResetMode));\n  }\n});\n\n// src/lib/git-logger.ts\n\nfunction createLog() {\n  return debug__WEBPACK_IMPORTED_MODULE_1__(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, { namespace: parentNamespace }) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(\n      spawned,\n      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)\n    );\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    \"use strict\";\n    init_utils();\n    debug__WEBPACK_IMPORTED_MODULE_1__.formatters.L = (value) => String(filterHasLength(value) ? value.length : \"-\");\n    debug__WEBPACK_IMPORTED_MODULE_1__.formatters.B = (value) => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar _TasksPendingQueue, TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_git_logger();\n    _TasksPendingQueue = class {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */ new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, { logger }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(\n              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`\n            );\n          } else {\n            logger.info(\n              `A fatal exception occurred in a previous task, the queue has been purged: %o`,\n              err.message\n            );\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n    };\n    TasksPendingQueue = _TasksPendingQueue;\n    TasksPendingQueue.counter = 0;\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\n\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return (err) => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return (buffer) => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      attemptTask(task) {\n        return __async(this, null, function* () {\n          const onScheduleComplete = yield this._scheduler.next();\n          const onQueueComplete = () => this._queue.complete(task);\n          try {\n            const { logger } = this._queue.attempt(task);\n            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);\n          } catch (e) {\n            throw this.onFatalException(task, e);\n          } finally {\n            onQueueComplete();\n            onScheduleComplete();\n          }\n        });\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      attemptRemoteTask(task, logger) {\n        return __async(this, null, function* () {\n          const binary = this._plugins.exec(\"spawn.binary\", \"\", pluginContext(task, task.commands));\n          const args = this._plugins.exec(\n            \"spawn.args\",\n            [...task.commands],\n            pluginContext(task, task.commands)\n          );\n          const raw = yield this.gitResponse(\n            task,\n            binary,\n            args,\n            this.outputHandler,\n            logger.step(\"SPAWN\")\n          );\n          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n          logger(`passing response to task's parser as a %s`, task.format);\n          if (isBufferTask(task)) {\n            return callTaskParser(task.parser, outputStreams);\n          }\n          return callTaskParser(task.parser, outputStreams.asStrings());\n        });\n      }\n      attemptEmptyTask(task, logger) {\n        return __async(this, null, function* () {\n          logger(`empty task bypassing child process to call to task's parser`);\n          return task.parser(this);\n        });\n      }\n      handleTaskData(task, args, result, logger) {\n        const { exitCode, rejection, stdOut, stdErr } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const { error } = this._plugins.exec(\n            \"task.error\",\n            { error: rejection },\n            __spreadValues(__spreadValues({}, pluginContext(task, args)), result)\n          );\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(\n              result,\n              error,\n              (newStdOut) => {\n                logger.info(`custom error handler treated as success`);\n                logger(`custom error returned a %s`, objectToString(newStdOut));\n                done(\n                  new GitOutputStreams(\n                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                    Buffer.concat(stdErr)\n                  )\n                );\n              },\n              fail\n            );\n          }\n          if (error) {\n            logger.info(\n              `handling as error: exitCode=%s stdErr=%s rejection=%o`,\n              exitCode,\n              stdErr.length,\n              rejection\n            );\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      gitResponse(task, command, args, outputHandler, logger) {\n        return __async(this, null, function* () {\n          const outputLogger = logger.sibling(\"output\");\n          const spawnOptions = this._plugins.exec(\n            \"spawn.options\",\n            {\n              cwd: this.cwd,\n              env: this.env,\n              windowsHide: true\n            },\n            pluginContext(task, task.commands)\n          );\n          return new Promise((done) => {\n            const stdOut = [];\n            const stdErr = [];\n            logger.info(`%s %o`, command, args);\n            logger(\"%O\", spawnOptions);\n            let rejection = this._beforeSpawn(task, args);\n            if (rejection) {\n              return done({\n                stdOut,\n                stdErr,\n                exitCode: 9901,\n                rejection\n              });\n            }\n            this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              kill(reason) {\n                rejection = reason || rejection;\n              }\n            }));\n            const spawned = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.spawn)(command, args, spawnOptions);\n            spawned.stdout.on(\n              \"data\",\n              onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\"))\n            );\n            spawned.stderr.on(\n              \"data\",\n              onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\"))\n            );\n            spawned.on(\"error\", onErrorReceived(stdErr, logger));\n            if (outputHandler) {\n              logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n            }\n            this._plugins.exec(\"spawn.after\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              spawned,\n              close(exitCode, reason) {\n                done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason\n                });\n              },\n              kill(reason) {\n                if (spawned.killed) {\n                  return;\n                }\n                rejection = reason;\n                spawned.kill(\"SIGINT\");\n              }\n            }));\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        }));\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    \"use strict\";\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(cwd, _scheduler, _plugins) {\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = (data) => {\n    callback(null, data);\n  };\n  const onError2 = (err) => {\n    if ((err == null ? void 0 : err.task) === task) {\n      callback(\n        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,\n        void 0\n      );\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = (name) => {\n    console.warn(\n      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`\n    );\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask((instance) => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(\n        checkoutTask(getTrailingOptions(arguments, 1)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/count-objects.ts\nfunction countObjectsResponse() {\n  return {\n    count: 0,\n    garbage: 0,\n    inPack: 0,\n    packs: 0,\n    prunePackable: 0,\n    size: 0,\n    sizeGarbage: 0,\n    sizePack: 0\n  };\n}\nfunction count_objects_default() {\n  return {\n    countObjects() {\n      return this._runTask({\n        commands: [\"count-objects\", \"--verbose\"],\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);\n        }\n      });\n    }\n  };\n}\nvar parser2;\nvar init_count_objects = __esm({\n  \"src/lib/tasks/count-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    parser2 = new LineParser(\n      /([a-z-]+): (\\d+)$/,\n      (result, [key, value]) => {\n        const property = asCamelCase(key);\n        if (result.hasOwnProperty(property)) {\n          result[property] = asNumber(value);\n        }\n      }\n    );\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers = [\n      new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n        result.branch = branch;\n        result.commit = commit;\n        result.root = !!root;\n      }),\n      new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n        const parts = author.split(\"<\");\n        const email = parts.pop();\n        if (!email || !email.includes(\"@\")) {\n          return;\n        }\n        result.author = {\n          email: email.substr(0, email.length - 1),\n          name: parts.join(\"<\").trim()\n        };\n      }),\n      new LineParser(\n        /(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g,\n        (result, [changes, insertions, deletions]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          result.summary.insertions = parseInt(insertions, 10) || 0;\n          result.summary.deletions = parseInt(deletions, 10) || 0;\n        }\n      ),\n      new LineParser(\n        /^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/,\n        (result, [changes, lines, direction]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          const count = parseInt(lines, 10) || 0;\n          if (direction === \"-\") {\n            result.summary.deletions = count;\n          } else if (direction === \"+\") {\n            result.summary.insertions = count;\n          }\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\n    \"-c\",\n    \"core.abbrev=40\",\n    \"commit\",\n    ...prefixedArray(message, \"-m\"),\n    ...files,\n    ...customArgs\n  ];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(\n        asArray(message),\n        asArray(filterType(rest[0], filterStringOrStringArray, [])),\n        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n      );\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(\n      `git.commit: requires the commit message to be supplied as a string/string[]`\n    );\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    \"use strict\";\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/first-commit.ts\nfunction first_commit_default() {\n  return {\n    firstCommit() {\n      return this._runTask(\n        straightThroughStringTask([\"rev-list\", \"--max-parents=0\", \"HEAD\"], true),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_first_commit = __esm({\n  \"src/lib/tasks/first-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    \"use strict\";\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    \"use strict\";\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    \"use strict\";\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    \"use strict\";\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser4 = diffSummaryParsers[format];\n  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_DiffSummary();\n    init_diff_name_status();\n    init_utils();\n    statParser = [\n      new LineParser(\n        /^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/,\n        (result, [file, changes, alterations = \"\"]) => {\n          result.files.push({\n            file: file.trim(),\n            changes: asNumber(changes),\n            insertions: alterations.replace(/[^+]/g, \"\").length,\n            deletions: alterations.replace(/[^-]/g, \"\").length,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(\n        /^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,\n        (result, [file, before, after]) => {\n          result.files.push({\n            file: file.trim(),\n            before: asNumber(before),\n            after: asNumber(after),\n            binary: true\n          });\n        }\n      ),\n      new LineParser(\n        /(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/,\n        (result, [changed, summary]) => {\n          const inserted = /(\\d+) i/.exec(summary);\n          const deleted = /(\\d+) d/.exec(summary);\n          result.changed = asNumber(changed);\n          result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);\n          result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);\n        }\n      )\n    ];\n    numStatParser = [\n      new LineParser(\n        /(\\d+)\\t(\\d+)\\t(.+)$/,\n        (result, [changesInsert, changesDelete, file]) => {\n          const insertions = asNumber(changesInsert);\n          const deletions = asNumber(changesDelete);\n          result.changed++;\n          result.insertions += insertions;\n          result.deletions += deletions;\n          result.files.push({\n            file,\n            changes: insertions + deletions,\n            insertions,\n            deletions,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          after: 0,\n          before: 0,\n          binary: true\n        });\n      })\n    ];\n    nameOnlyParser = [\n      new LineParser(/(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    nameStatusParser = [\n      new LineParser(\n        /([ACDMRTUXB])([0-9]{0,3})\\t(.[^\\t]*)(\\t(.[^\\t]*))?$/,\n        (result, [status, similarity, from, _to, to]) => {\n          result.changed++;\n          result.files.push({\n            file: to != null ? to : from,\n            changes: 0,\n            insertions: 0,\n            deletions: 0,\n            binary: false,\n            status: orVoid(isDiffNameStatus(status) && status),\n            from: orVoid(!!to && from !== to && from),\n            similarity: asNumber(similarity)\n          });\n        }\n      )\n    ];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce(\n    (line, field, index) => {\n      line[field] = tokens[index] || \"\";\n      return line;\n    },\n    /* @__PURE__ */ Object.create({ diff: null })\n  );\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function(stdOut) {\n    const all = toLinesWithContent(\n      stdOut.trim(),\n      false,\n      START_BOUNDARY\n    ).map(function(item) {\n      const lineDetail = item.split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(\n      `Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`\n    );\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(\n      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`\n    );\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach((field) => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [\n    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n    ...customArgs\n  ];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    command.push(\"--follow\", pathspec(opt.file));\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(\n        trailingOptionsArgument(arguments),\n        filterType(arguments[0], filterArray)\n      );\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(\n      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`\n    );\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_pathspec();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    \"use strict\";\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    \"use strict\";\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: { count: 0, delta: 0 },\n    total: { count: 0, delta: 0 }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    remoteMessagesObjectParsers = [\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i,\n        (result, [total, reused, packReused]) => {\n          const objects = objectEnumerationResult(result.remoteMessages);\n          objects.total = asObjectCount(total);\n          objects.reused = asObjectCount(reused);\n          objects.packReused = asNumber(packReused);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n        result.remoteMessages.all.push(text.trim());\n        return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser(\n        [/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [pullRequestUrl]) => {\n          result.remoteMessages.pullRequestUrl = pullRequestUrl;\n        }\n      ),\n      new RemoteLineParser(\n        [/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [count, summary, url]) => {\n          result.remoteMessages.vulnerabilities = {\n            count: asNumber(count),\n            summary,\n            url\n          };\n        }\n      )\n    ];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    \"use strict\";\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [\n      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n        result.files.push(file);\n        if (insertions) {\n          result.insertions[file] = insertions.length;\n        }\n        if (deletions) {\n          result.deletions[file] = deletions.length;\n        }\n      }),\n      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n        if (insertions !== void 0 || deletions !== void 0) {\n          result.summary.changes = +changes || 0;\n          result.summary.insertions = +insertions || 0;\n          result.summary.deletions = +deletions || 0;\n          return true;\n        }\n        return false;\n      }),\n      new LineParser(ACTION_REGEX, (result, [action, file]) => {\n        append(result.files, file);\n        append(action === \"create\" ? result.created : result.deleted, file);\n      })\n    ];\n    errorParsers = [\n      new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n      new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n      new LineParser(\n        /([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/,\n        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n          result.branch.local = branchLocal;\n          result.hash.local = hashLocal;\n          result.branch.remote = branchRemote;\n          result.hash.remote = hashRemote;\n        }\n      )\n    ];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(\n        new PullSummary(),\n        parsePullDetail(stdOut, stdErr),\n        parseRemoteMessages(stdOut, stdErr)\n      );\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    \"use strict\";\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [\n      new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n        summary.merges.push(autoMerge);\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file));\n      }),\n      new LineParser(\n        /^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/,\n        (summary, [reason, file, deleteRef]) => {\n          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n        }\n      ),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, null));\n      }),\n      new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n        summary.result = result;\n      })\n    ];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = (stdOut) => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [\n      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n        result.repo = repo;\n      }),\n      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {\n          local\n        });\n      }),\n      new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n        result.pushed.push(pushResultPushedItem(local, remote, type));\n      }),\n      new LineParser(\n        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,\n        (result, [local, remote, remoteName]) => {\n          result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {\n            local,\n            remote,\n            remoteName\n          });\n        }\n      ),\n      new LineParser(\n        /^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/,\n        (result, [local, remote, from, to]) => {\n          result.update = {\n            head: {\n              local,\n              remote\n            },\n            hash: {\n              from,\n              to\n            }\n          };\n        }\n      )\n    ];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    \"use strict\";\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/show.ts\nfunction show_default() {\n  return {\n    showBuffer() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      if (!commands.includes(\"--binary\")) {\n        commands.splice(1, 0, \"--binary\");\n      }\n      return this._runTask(\n        straightThroughBufferTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    show() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      return this._runTask(\n        straightThroughStringTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_show = __esm({\n  \"src/lib/tasks/show.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    \"use strict\";\n    fromPathRegex = /^(.+)\\0(.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index === \"R\" || working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[2] || \"\";\n          this.path = detail[1] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser3(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path, index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([\n      parser3(\n        \" \" /* NONE */,\n        \"A\" /* ADDED */,\n        (result, file) => append(result.created, file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"D\" /* DELETED */,\n        (result, file) => append(result.deleted, file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.modified, file)\n      ),\n      parser3(\n        \"A\" /* ADDED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.created, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"A\" /* ADDED */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)\n      ),\n      parser3(\n        \"D\" /* DELETED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.deleted, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"M\" /* MODIFIED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.modified, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"M\" /* MODIFIED */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.modified, file) && append(result.staged, file)\n      ),\n      parser3(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n        append(result.renamed, renamedFile(file));\n      }),\n      parser3(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n        const renamed = renamedFile(file);\n        append(result.renamed, renamed);\n        append(result.modified, renamed.to);\n      }),\n      parser3(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n        append(_result.ignored = _result.ignored || [], _file);\n      }),\n      parser3(\n        \"?\" /* UNTRACKED */,\n        \"?\" /* UNTRACKED */,\n        (result, file) => append(result.not_added, file)\n      ),\n      ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */),\n      ...conflicts(\n        \"D\" /* DELETED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      ...conflicts(\n        \"U\" /* UNMERGED */,\n        \"A\" /* ADDED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      [\n        \"##\",\n        (result, line) => {\n          const aheadReg = /ahead (\\d+)/;\n          const behindReg = /behind (\\d+)/;\n          const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n          const trackingReg = /\\.{3}(\\S*)/;\n          const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n          let regexResult;\n          regexResult = aheadReg.exec(line);\n          result.ahead = regexResult && +regexResult[1] || 0;\n          regexResult = behindReg.exec(line);\n          result.behind = regexResult && +regexResult[1] || 0;\n          regexResult = currentReg.exec(line);\n          result.current = regexResult && regexResult[1];\n          regexResult = trackingReg.exec(line);\n          result.tracking = regexResult && regexResult[1];\n          regexResult = onEmptyBranchReg.exec(line);\n          result.current = regexResult && regexResult[1] || result.current;\n          result.detached = /\\(no branch\\)/.test(line);\n        }\n      ]\n    ]);\n    parseStatusSummary = function(text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l; ) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\n    \"status\",\n    \"--porcelain\",\n    \"-b\",\n    \"-u\",\n    \"--null\",\n    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))\n  ];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    \"use strict\";\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty(\n    {\n      major,\n      minor,\n      patch,\n      agent,\n      installed\n    },\n    \"toString\",\n    {\n      value() {\n        return `${this.major}.${this.minor}.${this.patch}`;\n      },\n      configurable: false,\n      enumerable: false\n    }\n  );\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    \"use strict\";\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(\n            result,\n            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)\n          );\n        }\n      ),\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    \"use strict\";\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_count_objects();\n    init_commit();\n    init_config();\n    init_first_commit();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_show();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: { value: promise.then.bind(promise) },\n          catch: { value: promise.catch.bind(promise) },\n          _executor: { value: chain }\n        });\n      }\n      add(files) {\n        return this._runTask(\n          straightThroughStringTask([\"add\", ...asArray(files)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof (directory == null ? void 0 : directory.path) === \"string\") {\n          return this._runTask(\n            changeWorkingDirectoryTask(\n              directory.path,\n              directory.root && this._executor || void 0\n            ),\n            next\n          );\n        }\n        return this._runTask(\n          configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"),\n          next\n        );\n      }\n      hashObject(path, write) {\n        return this._runTask(\n          hashObjectTask(path, write === true),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      init(bare) {\n        return this._runTask(\n          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      merge() {\n        return this._runTask(\n          mergeTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(\n            configurationErrorTask(\n              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n            )\n          );\n        }\n        return this._runTask(\n          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments, false)\n        );\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask(\n          {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString)\n          },\n          getTrailingOptions(arguments)\n        );\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(\n          straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      status() {\n        return this._runTask(\n          statusTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n    };\n    Object.assign(\n      SimpleGitApi.prototype,\n      checkout_default(),\n      commit_default(),\n      config_default(),\n      count_objects_default(),\n      first_commit_default(),\n      grep_default(),\n      log_default(),\n      show_default(),\n      version_default()\n    );\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\n\nvar createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_git_logger();\n    createScheduledTask = (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const { promise, done } = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.createDeferred)();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(\n            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,\n            this.pending.length,\n            this.running.length,\n            this.concurrency\n          );\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const { promise, id } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    \"use strict\";\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    \"use strict\";\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [\n      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n        const deletion = branchDeletionSuccess(branch, hash);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      }),\n      new LineParser(deleteErrorRegex, (result, [branch]) => {\n        const deletion = branchDeletionFailure(branch);\n        result.errors.push(deletion);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      })\n    ];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    \"use strict\";\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut) {\n  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);\n}\nvar parsers9;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    \"use strict\";\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [\n      new LineParser(\n        /^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), true, name, commit, label);\n        }\n      ),\n      new LineParser(\n        new RegExp(\"^([*+]\\\\s)?(\\\\S+)\\\\s+([a-z0-9]+)\\\\s?(.*)$\", \"s\"),\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), false, name, commit, label);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some((command) => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction branchLocalTask() {\n  const parser4 = parseBranchSummary;\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser: parser4\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({ exitCode, stdOut }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(\n        task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n        String(error)\n      );\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    \"use strict\";\n    parseCheckIgnore = (text) => {\n      return text.split(/\\n/g).map((line) => line.trim()).filter((file) => !!file);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    \"use strict\";\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    \"use strict\";\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers10 = [\n      new LineParser(/From (.+)$/, (result, [remote]) => {\n        result.remote = remote;\n      }),\n      new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.branches.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.tags.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n        result.deleted.push({\n          tracking\n        });\n      }),\n      new LineParser(\n        /\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/,\n        (result, [from, to, name, tracking]) => {\n          result.updated.push({\n            name,\n            tracking,\n            to,\n            from\n          });\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    \"use strict\";\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({ moves: [] }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers11 = [\n      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n        result.moves.push({ from, to });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    \"use strict\";\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(\n        bufferToString(result.stdOut),\n        bufferToString(result.stdErr)\n      );\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = { name });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!remotes.hasOwnProperty(name)) {\n      remotes[name] = {\n        name,\n        refs: { fetch: \"\", push: \"\" }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    \"use strict\";\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser4 = createListLogSummaryParser(\n    options.splitter,\n    options.fields,\n    logFormatFromCommand(commands)\n  );\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = isNaN(a);\n  const bIsNum = isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    \"use strict\";\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function(data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function(tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return { name };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return { name };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    \"use strict\";\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports, module) {\n    \"use strict\";\n    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));\n    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));\n    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));\n    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));\n    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));\n    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));\n    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));\n    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));\n    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._plugins = plugins;\n      this._executor = new GitExecutor2(\n        options.baseDir,\n        new Scheduler2(options.maxConcurrentProcesses),\n        plugins\n      );\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function(command) {\n      this._plugins.reconfigure(\"binary\", command);\n      return this;\n    };\n    Git2.prototype.env = function(name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function(options) {\n      return this._runTask(\n        stashListTask2(\n          trailingOptionsArgument2(arguments) || {},\n          filterArray2(options) && options || []\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function() {\n      return this._runTask(\n        createCloneTask(\"clone\", cloneTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mirror = function() {\n      return this._runTask(\n        createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mv = function(from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function(then) {\n      var git = this;\n      return this.pull(function() {\n        git.tags(function(err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function(remote, branch, options, then) {\n      return this._runTask(\n        pullTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.fetch = function(remote, branch) {\n      return this._runTask(\n        fetchTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.silent = function(silence) {\n      console.warn(\n        \"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3\"\n      );\n      return this;\n    };\n    Git2.prototype.tags = function(options, then) {\n      return this._runTask(\n        tagListTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rebase = function() {\n      return this._runTask(\n        straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.reset = function(mode) {\n      return this._runTask(\n        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.revert = function(commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(\n        straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]),\n        next\n      );\n    };\n    Git2.prototype.addTag = function(name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {\n      return this._runTask(\n        addAnnotatedTagTask2(tagName, tagMessage),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {\n      return this._runTask(\n        deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {\n      return this._runTask(\n        deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branch = function(options, then) {\n      return this._runTask(\n        branchTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branchLocal = function(then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function(commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(\n          configurationErrorTask2(\"Raw: must supply one or more command to execute\"),\n          next\n        );\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function(repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function(args, then) {\n      return this._runTask(\n        updateSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.submoduleInit = function(args, then) {\n      return this._runTask(\n        initSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.subModule = function(options, then) {\n      return this._runTask(\n        subModuleTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.listRemote = function() {\n      return this._runTask(\n        listRemotesTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {\n      return this._runTask(\n        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.removeRemote = function(remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function(verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function(options, then) {\n      return this._runTask(\n        remoteTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.tag = function(options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function(then) {\n      return this._runTask(\n        straightThroughStringTask2([\"update-server-info\"]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.pushTags = function(remote, then) {\n      const task = pushTagsTask2(\n        { remote: filterType2(remote, filterString2) },\n        getTrailingOptions2(arguments)\n      );\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rmKeepLocal = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.catFile = function(options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function() {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function(format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(\n          configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"),\n          handler\n        );\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function(options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\n        \"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\"\n      ) : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function() {\n      return this._runTask(\n        diffSummaryTask2(getTrailingOptions2(arguments, 1)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.applyPatch = function(patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(\n        `git.applyPatch requires one or more string patches as the first argument`\n      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function() {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(\n        straightThroughStringTask2(commands, true),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.clean = function(mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(\n        cleanWithOptionsTask2(cleanMode, customArgs),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.exec = function(then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function() {\n      return this;\n    };\n    Git2.prototype.checkIgnore = function(pathnames, then) {\n      return this._runTask(\n        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.checkIsRepo = function(checkType, then) {\n      return this._runTask(\n        checkIsRepoTask2(filterType2(checkType, filterString2)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    module.exports = Git2;\n  }\n});\n\n// src/lib/api.ts\ninit_pathspec();\n\n// src/lib/errors/git-construct-error.ts\ninit_git_error();\nvar GitConstructError = class extends GitError {\n  constructor(config, message) {\n    super(void 0, message);\n    this.config = config;\n  }\n};\n\n// src/lib/api.ts\ninit_git_error();\n\n// src/lib/errors/git-plugin-error.ts\ninit_git_error();\nvar GitPluginError = class extends GitError {\n  constructor(task, plugin, message) {\n    super(task, message);\n    this.task = task;\n    this.plugin = plugin;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// src/lib/api.ts\ninit_git_response_error();\ninit_task_configuration_error();\ninit_check_is_repo();\ninit_clean();\ninit_config();\ninit_diff_name_status();\ninit_grep();\ninit_reset();\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(\n    void 0,\n    \"unsafe\",\n    \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\"\n  );\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"clone\" && /^\\s*-u\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of clone with option -u is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of push with option --exec is not permitted without enabling allowUnsafePack`\n    );\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\ninit_utils();\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\n\n// src/lib/plugins/completion-detection.plugin.ts\ninit_utils();\n\nvar never = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)().promise;\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)(),\n      closeTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)(),\n      exit: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)(),\n      exitTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)()\n    };\n    const result = Promise.race([\n      onClose === false ? never : events.closeTimeout.promise,\n      onExit === false ? never : events.exitTimeout.promise\n    ]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    action(_0, _1) {\n      return __async(this, arguments, function* (_data, { spawned, close }) {\n        var _a3, _b;\n        const events = createEvents();\n        let deferClose = true;\n        let quickClose = () => void (deferClose = false);\n        (_a3 = spawned.stdout) == null ? void 0 : _a3.on(\"data\", quickClose);\n        (_b = spawned.stderr) == null ? void 0 : _b.on(\"data\", quickClose);\n        spawned.on(\"error\", quickClose);\n        spawned.on(\"close\", (code) => events.close(code));\n        spawned.on(\"exit\", (code) => events.exit(code));\n        try {\n          yield events.result;\n          if (deferClose) {\n            yield delay(50);\n          }\n          close(events.exitCode);\n        } catch (err) {\n          close(events.exitCode, err);\n        }\n      });\n    }\n  };\n}\n\n// src/lib/plugins/custom-binary.plugin.ts\ninit_utils();\nvar WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;\nvar WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;\nfunction isBadArgument(arg) {\n  return !arg || !/^([a-z]:)?([a-z0-9/.\\\\_-]+)$/i.test(arg);\n}\nfunction toBinaryConfig(input, allowUnsafe) {\n  if (input.length < 1 || input.length > 2) {\n    throw new GitPluginError(void 0, \"binary\", WRONG_NUMBER_ERR);\n  }\n  const isBad = input.some(isBadArgument);\n  if (isBad) {\n    if (allowUnsafe) {\n      console.warn(WRONG_CHARS_ERR);\n    } else {\n      throw new GitPluginError(void 0, \"binary\", WRONG_CHARS_ERR);\n    }\n  }\n  const [binary, prefix] = input;\n  return {\n    binary,\n    prefix\n  };\n}\nfunction customBinaryPlugin(plugins, input = [\"git\"], allowUnsafe = false) {\n  let config = toBinaryConfig(asArray(input), allowUnsafe);\n  plugins.on(\"binary\", (input2) => {\n    config = toBinaryConfig(asArray(input2), allowUnsafe);\n  });\n  plugins.append(\"spawn.binary\", () => {\n    return config.binary;\n  });\n  plugins.append(\"spawn.args\", (data) => {\n    return config.prefix ? [config.prefix, ...data] : data;\n  });\n}\n\n// src/lib/plugins/error-detection.plugin.ts\ninit_git_error();\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return { error: new GitError(void 0, error.toString(\"utf-8\")) };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\n\n// src/lib/plugins/plugin-store.ts\ninit_utils();\n\nvar PluginStore = class {\n  constructor() {\n    this.plugins = /* @__PURE__ */ new Set();\n    this.events = new node_events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter();\n  }\n  on(type, listener) {\n    this.events.on(type, listener);\n  }\n  reconfigure(type, data) {\n    this.events.emit(type, data);\n  }\n  append(type, action) {\n    const plugin = append(this.plugins, { type, action });\n    return () => this.plugins.delete(plugin);\n  }\n  add(plugin) {\n    const plugins = [];\n    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));\n    return () => {\n      plugins.forEach((plugin2) => this.plugins.delete(plugin2));\n    };\n  }\n  exec(type, data, context) {\n    let output = data;\n    const contextual = Object.freeze(Object.create(context));\n    for (const plugin of this.plugins) {\n      if (plugin.type === type) {\n        output = plugin.action(output, contextual);\n      }\n    }\n    return output;\n  }\n};\n\n// src/lib/plugins/progress-monitor-plugin.ts\ninit_utils();\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      var _a2;\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on(\"data\", (chunk) => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\n\n// src/lib/plugins/spawn-options-plugin.ts\ninit_utils();\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return __spreadValues(__spreadValues({}, options), data);\n    }\n  };\n}\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        var _a2, _b;\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          var _a3, _b2;\n          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off(\"data\", wait);\n          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on(\"data\", wait));\n        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on(\"data\", wait));\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\n\n// src/lib/plugins/suffix-paths.plugin.ts\ninit_pathspec();\nfunction suffixPathsPlugin() {\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      const prefix = [];\n      let suffix;\n      function append2(args) {\n        (suffix = suffix || []).push(...args);\n      }\n      for (let i = 0; i < data.length; i++) {\n        const param = data[i];\n        if (isPathSpec(param)) {\n          append2(toPaths(param));\n          continue;\n        }\n        if (param === \"--\") {\n          append2(\n            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)\n          );\n          break;\n        }\n        prefix.push(param);\n      }\n      return !suffix ? prefix : [...prefix, \"--\", ...suffix.map(String)];\n    }\n  };\n}\n\n// src/lib/git-factory.ts\ninit_utils();\nvar Git = require_git();\nfunction gitInstanceFactory(baseDir, options) {\n  var _a2;\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(\n    baseDir && (typeof baseDir === \"string\" ? { baseDir } : baseDir) || {},\n    options\n  );\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(\n      config,\n      `Cannot use simple-git on a directory that does not exist`\n    );\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(suffixPathsPlugin());\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  customBinaryPlugin(plugins, config.binary, (_a2 = config.unsafe) == null ? void 0 : _a2.allowUnsafeCustomBinary);\n  return new Git(config, plugins);\n}\n\n// src/lib/runners/promise-wrapped.ts\ninit_git_response_error();\nvar functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\nvar functionNamesPromiseApi = [\n  \"add\",\n  \"addAnnotatedTag\",\n  \"addConfig\",\n  \"addRemote\",\n  \"addTag\",\n  \"applyPatch\",\n  \"binaryCatFile\",\n  \"branch\",\n  \"branchLocal\",\n  \"catFile\",\n  \"checkIgnore\",\n  \"checkIsRepo\",\n  \"checkout\",\n  \"checkoutBranch\",\n  \"checkoutLatestTag\",\n  \"checkoutLocalBranch\",\n  \"clean\",\n  \"clone\",\n  \"commit\",\n  \"cwd\",\n  \"deleteLocalBranch\",\n  \"deleteLocalBranches\",\n  \"diff\",\n  \"diffSummary\",\n  \"exec\",\n  \"fetch\",\n  \"getRemotes\",\n  \"init\",\n  \"listConfig\",\n  \"listRemote\",\n  \"log\",\n  \"merge\",\n  \"mergeFromTo\",\n  \"mirror\",\n  \"mv\",\n  \"pull\",\n  \"push\",\n  \"pushTags\",\n  \"raw\",\n  \"rebase\",\n  \"remote\",\n  \"removeRemote\",\n  \"reset\",\n  \"revert\",\n  \"revparse\",\n  \"rm\",\n  \"rmKeepLocal\",\n  \"show\",\n  \"stash\",\n  \"stashList\",\n  \"status\",\n  \"subModule\",\n  \"submoduleAdd\",\n  \"submoduleInit\",\n  \"submoduleUpdate\",\n  \"tag\",\n  \"tags\",\n  \"updateServerInfo\"\n];\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(\n    (api, name) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n      Object.defineProperty(api, name, {\n        enumerable: false,\n        configurable: false,\n        value: git ? valid : alternative\n      });\n      return api;\n    },\n    {}\n  );\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function(...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\n          \"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn\n        );\n      }\n      return chain.then(function() {\n        return new Promise(function(resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\n\n// src/esm.mjs\nvar simpleGit = gitInstanceFactory;\nvar esm_default = gitInstanceFactory;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFNLE9BQU8sd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCwrQkFBK0IsSUFBSTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdCQUF3QjtBQUM3QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1GQUFtRixLQUFLO0FBQ3hGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUMwQjtBQUMxQjtBQUNBLFNBQVMsa0NBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQSxpREFBaUQsYUFBYSxFQUFFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFnQjtBQUNwQixJQUFJLDZDQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCLG9EQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxNQUFNLGlDQUFpQyxLQUFLO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZSxFQUFFLGNBQWMsRUFBRSxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQkFBMEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQjtBQUMzQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUsR0FBRyxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEM7QUFDOUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQkFBcUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sRUFBRSxPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLEVBQUUsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUMsa0NBQWtDLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUN6RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRCxtQkFBbUIsb0NBQW9DO0FBQ3ZELHVCQUF1QjtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQixFQUFFLHlFQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QyxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSw4QkFBOEI7QUFDeEMsVUFBVSx3QkFBd0I7QUFDbEMsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLG9DQUFvQztBQUM5QyxVQUFVLG9DQUFvQztBQUM5QyxVQUFVLDJEQUEyRDtBQUNyRSxVQUFVLHlGQUF5RjtBQUNuRyxVQUFVLG9DQUFvQztBQUM5QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLHNCQUFzQjtBQUNoQyxVQUFVLHNCQUFzQjtBQUNoQyxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLGdHQUFnRztBQUMxRyxVQUFVLCtHQUErRztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDcUQ7QUFDckQsWUFBWSxtRUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFRO0FBQ3JCLG9CQUFvQixtRUFBUTtBQUM1QixZQUFZLG1FQUFRO0FBQ3BCLG1CQUFtQixtRUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQWlCRTtBQUNGIiwic291cmNlcyI6WyJEOlxcU0xJSVRcXFJlc2VhcmNoXFxBSS1Qb3dlcmVkLUludGVncmF0ZWQtQ29kZS1BbmFseXplci1mb3ItRWZmaWNpZW50LURldmVsb3Blci1Xb3JrRmxvd1xcZG9jYWlcXG5vZGVfbW9kdWxlc1xcc2ltcGxlLWdpdFxcZGlzdFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fZXNtID0gKGZuLCByZXMpID0+IGZ1bmN0aW9uIF9faW5pdCgpIHtcbiAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bX19nZXRPd25Qcm9wTmFtZXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlcztcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2xpYi9hcmdzL3BhdGhzcGVjLnRzXG5mdW5jdGlvbiBwYXRoc3BlYyguLi5wYXRocykge1xuICBjb25zdCBrZXkgPSBuZXcgU3RyaW5nKHBhdGhzKTtcbiAgY2FjaGUuc2V0KGtleSwgcGF0aHMpO1xuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gaXNQYXRoU3BlYyhwYXRoKSB7XG4gIHJldHVybiBwYXRoIGluc3RhbmNlb2YgU3RyaW5nICYmIGNhY2hlLmhhcyhwYXRoKTtcbn1cbmZ1bmN0aW9uIHRvUGF0aHMocGF0aFNwZWMpIHtcbiAgcmV0dXJuIGNhY2hlLmdldChwYXRoU3BlYykgfHwgW107XG59XG52YXIgY2FjaGU7XG52YXIgaW5pdF9wYXRoc3BlYyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2FyZ3MvcGF0aHNwZWMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9lcnJvcnMvZ2l0LWVycm9yLnRzXG52YXIgR2l0RXJyb3I7XG52YXIgaW5pdF9naXRfZXJyb3IgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9lcnJvcnMvZ2l0LWVycm9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgR2l0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKHRhc2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvci50c1xudmFyIEdpdFJlc3BvbnNlRXJyb3I7XG52YXIgaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBHaXRSZXNwb25zZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihnaXQsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodm9pZCAwLCBtZXNzYWdlIHx8IFN0cmluZyhnaXQpKTtcbiAgICAgICAgdGhpcy5naXQgPSBnaXQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvci50c1xudmFyIFRhc2tDb25maWd1cmF0aW9uRXJyb3I7XG52YXIgaW5pdF90YXNrX2NvbmZpZ3VyYXRpb25fZXJyb3IgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBUYXNrQ29uZmlndXJhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZvaWQgMCwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvdXRpbC50c1xuaW1wb3J0IHsgZXhpc3RzLCBGT0xERVIgfSBmcm9tIFwiQGt3c2l0ZXMvZmlsZS1leGlzdHNcIjtcbmZ1bmN0aW9uIGFzRnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiB0eXBlb2Ygc291cmNlID09PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UgOiBOT09QO1xufVxuZnVuY3Rpb24gaXNVc2VyRnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiB0eXBlb2Ygc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiYgc291cmNlICE9PSBOT09QO1xufVxuZnVuY3Rpb24gc3BsaXRPbihpbnB1dCwgY2hhcikge1xuICBjb25zdCBpbmRleCA9IGlucHV0LmluZGV4T2YoY2hhcik7XG4gIGlmIChpbmRleCA8PSAwKSB7XG4gICAgcmV0dXJuIFtpbnB1dCwgXCJcIl07XG4gIH1cbiAgcmV0dXJuIFtpbnB1dC5zdWJzdHIoMCwgaW5kZXgpLCBpbnB1dC5zdWJzdHIoaW5kZXggKyAxKV07XG59XG5mdW5jdGlvbiBmaXJzdChpbnB1dCwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gaXNBcnJheUxpa2UoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA+IG9mZnNldCA/IGlucHV0W29mZnNldF0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBsYXN0KGlucHV0LCBvZmZzZXQgPSAwKSB7XG4gIGlmIChpc0FycmF5TGlrZShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGlucHV0W2lucHV0Lmxlbmd0aCAtIDEgLSBvZmZzZXRdO1xuICB9XG59XG5mdW5jdGlvbiBpc0FycmF5TGlrZShpbnB1dCkge1xuICByZXR1cm4gISEoaW5wdXQgJiYgdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiB0b0xpbmVzV2l0aENvbnRlbnQoaW5wdXQgPSBcIlwiLCB0cmltbWVkMiA9IHRydWUsIHNlcGFyYXRvciA9IFwiXFxuXCIpIHtcbiAgcmV0dXJuIGlucHV0LnNwbGl0KHNlcGFyYXRvcikucmVkdWNlKChvdXRwdXQsIGxpbmUpID0+IHtcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IHRyaW1tZWQyID8gbGluZS50cmltKCkgOiBsaW5lO1xuICAgIGlmIChsaW5lQ29udGVudCkge1xuICAgICAgb3V0cHV0LnB1c2gobGluZUNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBmb3JFYWNoTGluZVdpdGhDb250ZW50KGlucHV0LCBjYWxsYmFjaykge1xuICByZXR1cm4gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0LCB0cnVlKS5tYXAoKGxpbmUpID0+IGNhbGxiYWNrKGxpbmUpKTtcbn1cbmZ1bmN0aW9uIGZvbGRlckV4aXN0cyhwYXRoKSB7XG4gIHJldHVybiBleGlzdHMocGF0aCwgRk9MREVSKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGlmICghdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGluZyh0YXJnZXQsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHJlbW92ZSh0YXJnZXQsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuZGVsZXRlKGl0ZW0pO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gYXNBcnJheShzb3VyY2UpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xufVxuZnVuY3Rpb24gYXNDYW1lbENhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xccy1dKyguKS9nLCAoX2FsbCwgY2hyKSA9PiB7XG4gICAgcmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFzU3RyaW5nQXJyYXkoc291cmNlKSB7XG4gIHJldHVybiBhc0FycmF5KHNvdXJjZSkubWFwKFN0cmluZyk7XG59XG5mdW5jdGlvbiBhc051bWJlcihzb3VyY2UsIG9uTmFOID0gMCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICByZXR1cm4gb25OYU47XG4gIH1cbiAgY29uc3QgbnVtID0gcGFyc2VJbnQoc291cmNlLCAxMCk7XG4gIHJldHVybiBpc05hTihudW0pID8gb25OYU4gOiBudW07XG59XG5mdW5jdGlvbiBwcmVmaXhlZEFycmF5KGlucHV0LCBwcmVmaXgpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbnB1dC5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgIG91dHB1dC5wdXNoKHByZWZpeCwgaW5wdXRbaV0pO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBidWZmZXJUb1N0cmluZyhpbnB1dCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW5wdXQpID8gQnVmZmVyLmNvbmNhdChpbnB1dCkgOiBpbnB1dCkudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbn1cbmZ1bmN0aW9uIHBpY2soc291cmNlLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIC4uLnByb3BlcnRpZXMubWFwKChwcm9wZXJ0eSkgPT4gcHJvcGVydHkgaW4gc291cmNlID8geyBbcHJvcGVydHldOiBzb3VyY2VbcHJvcGVydHldIH0gOiB7fSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRlbGF5KGR1cmF0aW9uID0gMCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHNldFRpbWVvdXQoZG9uZSwgZHVyYXRpb24pKTtcbn1cbmZ1bmN0aW9uIG9yVm9pZChpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG52YXIgTlVMTCwgTk9PUCwgb2JqZWN0VG9TdHJpbmc7XG52YXIgaW5pdF91dGlsID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvdXRpbC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE5VTEwgPSBcIlxcMFwiO1xuICAgIE5PT1AgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9hcmd1bWVudC1maWx0ZXJzLnRzXG5mdW5jdGlvbiBmaWx0ZXJUeXBlKGlucHV0LCBmaWx0ZXIsIGRlZikge1xuICBpZiAoZmlsdGVyKGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBkZWYgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmaWx0ZXJQcmltaXRpdmVzKGlucHV0LCBvbWl0KSB7XG4gIGNvbnN0IHR5cGUgPSBpc1BhdGhTcGVjKGlucHV0KSA/IFwic3RyaW5nXCIgOiB0eXBlb2YgaW5wdXQ7XG4gIHJldHVybiAvbnVtYmVyfHN0cmluZ3xib29sZWFuLy50ZXN0KHR5cGUpICYmICghb21pdCB8fCAhb21pdC5pbmNsdWRlcyh0eXBlKSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJQbGFpbk9iamVjdChpbnB1dCkge1xuICByZXR1cm4gISFpbnB1dCAmJiBvYmplY3RUb1N0cmluZyhpbnB1dCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCI7XG59XG52YXIgZmlsdGVyQXJyYXksIGZpbHRlclN0cmluZywgZmlsdGVyU3RyaW5nQXJyYXksIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksIGZpbHRlckhhc0xlbmd0aDtcbnZhciBpbml0X2FyZ3VtZW50X2ZpbHRlcnMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9hcmd1bWVudC1maWx0ZXJzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlsKCk7XG4gICAgaW5pdF9wYXRoc3BlYygpO1xuICAgIGZpbHRlckFycmF5ID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCk7XG4gICAgfTtcbiAgICBmaWx0ZXJTdHJpbmcgPSAoaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCI7XG4gICAgfTtcbiAgICBmaWx0ZXJTdHJpbmdBcnJheSA9IChpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGZpbHRlclN0cmluZyk7XG4gICAgfTtcbiAgICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5ID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyU3RyaW5nKGlucHV0KSB8fCBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeShmaWx0ZXJTdHJpbmcpO1xuICAgIH07XG4gICAgZmlsdGVySGFzTGVuZ3RoID0gKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQgPT0gbnVsbCB8fCBcIm51bWJlcnxib29sZWFufGZ1bmN0aW9uXCIuaW5jbHVkZXModHlwZW9mIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpbnB1dC5sZW5ndGggPT09IFwibnVtYmVyXCI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvZXhpdC1jb2Rlcy50c1xudmFyIEV4aXRDb2RlcztcbnZhciBpbml0X2V4aXRfY29kZXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9leGl0LWNvZGVzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgRXhpdENvZGVzID0gLyogQF9fUFVSRV9fICovICgoRXhpdENvZGVzMikgPT4ge1xuICAgICAgRXhpdENvZGVzMltFeGl0Q29kZXMyW1wiU1VDQ0VTU1wiXSA9IDBdID0gXCJTVUNDRVNTXCI7XG4gICAgICBFeGl0Q29kZXMyW0V4aXRDb2RlczJbXCJFUlJPUlwiXSA9IDFdID0gXCJFUlJPUlwiO1xuICAgICAgRXhpdENvZGVzMltFeGl0Q29kZXMyW1wiTk9UX0ZPVU5EXCJdID0gLTJdID0gXCJOT1RfRk9VTkRcIjtcbiAgICAgIEV4aXRDb2RlczJbRXhpdENvZGVzMltcIlVOQ0xFQU5cIl0gPSAxMjhdID0gXCJVTkNMRUFOXCI7XG4gICAgICByZXR1cm4gRXhpdENvZGVzMjtcbiAgICB9KShFeGl0Q29kZXMgfHwge30pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9naXQtb3V0cHV0LXN0cmVhbXMudHNcbnZhciBHaXRPdXRwdXRTdHJlYW1zO1xudmFyIGluaXRfZ2l0X291dHB1dF9zdHJlYW1zID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvZ2l0LW91dHB1dC1zdHJlYW1zLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgR2l0T3V0cHV0U3RyZWFtcyA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgIHRoaXMuc3RkT3V0ID0gc3RkT3V0O1xuICAgICAgICB0aGlzLnN0ZEVyciA9IHN0ZEVycjtcbiAgICAgIH1cbiAgICAgIGFzU3RyaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHaXRPdXRwdXRTdHJlYW1zKHRoaXMuc3RkT3V0LnRvU3RyaW5nKFwidXRmOFwiKSwgdGhpcy5zdGRFcnIudG9TdHJpbmcoXCJ1dGY4XCIpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9saW5lLXBhcnNlci50c1xudmFyIExpbmVQYXJzZXIsIFJlbW90ZUxpbmVQYXJzZXI7XG52YXIgaW5pdF9saW5lX3BhcnNlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL2xpbmUtcGFyc2VyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgTGluZVBhcnNlciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJlZ0V4cCwgdXNlTWF0Y2hlcykge1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJzZSA9IChsaW5lLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgIGlmICghdGhpcy5fcmVnRXhwLmV2ZXJ5KChyZWcsIGluZGV4KSA9PiB0aGlzLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUoaW5kZXgpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXNlTWF0Y2hlcyh0YXJnZXQsIHRoaXMucHJlcGFyZU1hdGNoZXMoKSkgIT09IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZWdFeHAgPSBBcnJheS5pc0FycmF5KHJlZ0V4cCkgPyByZWdFeHAgOiBbcmVnRXhwXTtcbiAgICAgICAgaWYgKHVzZU1hdGNoZXMpIHtcbiAgICAgICAgICB0aGlzLnVzZU1hdGNoZXMgPSB1c2VNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1c2VNYXRjaGVzKHRhcmdldCwgbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lUGFyc2VyOnVzZU1hdGNoZXMgbm90IGltcGxlbWVudGVkYCk7XG4gICAgICB9XG4gICAgICByZXNldE1hdGNoZXMoKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgcHJlcGFyZU1hdGNoZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgICB9XG4gICAgICBhZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBsaW5lICYmIHJlZy5leGVjKGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIHRoaXMucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFtYXRjaGVkO1xuICAgICAgfVxuICAgICAgcHVzaE1hdGNoKF9pbmRleCwgbWF0Y2hlZCkge1xuICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCguLi5tYXRjaGVkLnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFJlbW90ZUxpbmVQYXJzZXIgPSBjbGFzcyBleHRlbmRzIExpbmVQYXJzZXIge1xuICAgICAgYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZSkge1xuICAgICAgICByZXR1cm4gL15yZW1vdGU6XFxzLy50ZXN0KFN0cmluZyhsaW5lKSkgJiYgc3VwZXIuYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZSk7XG4gICAgICB9XG4gICAgICBwdXNoTWF0Y2goaW5kZXgsIG1hdGNoZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gMCB8fCBtYXRjaGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdXBlci5wdXNoTWF0Y2goaW5kZXgsIG1hdGNoZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvc2ltcGxlLWdpdC1vcHRpb25zLnRzXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUNvbmZpZyguLi5vcHRpb25zKSB7XG4gIGNvbnN0IGJhc2VEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKFxuICAgIF9fc3ByZWFkVmFsdWVzKHsgYmFzZURpciB9LCBkZWZhdWx0T3B0aW9ucyksXG4gICAgLi4ub3B0aW9ucy5maWx0ZXIoKG8pID0+IHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8pXG4gICk7XG4gIGNvbmZpZy5iYXNlRGlyID0gY29uZmlnLmJhc2VEaXIgfHwgYmFzZURpcjtcbiAgY29uZmlnLnRyaW1tZWQgPSBjb25maWcudHJpbW1lZCA9PT0gdHJ1ZTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbnZhciBkZWZhdWx0T3B0aW9ucztcbnZhciBpbml0X3NpbXBsZV9naXRfb3B0aW9ucyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL3NpbXBsZS1naXQtb3B0aW9ucy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYmluYXJ5OiBcImdpdFwiLFxuICAgICAgbWF4Q29uY3VycmVudFByb2Nlc3NlczogNSxcbiAgICAgIGNvbmZpZzogW10sXG4gICAgICB0cmltbWVkOiBmYWxzZVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL3Rhc2stb3B0aW9ucy50c1xuZnVuY3Rpb24gYXBwZW5kVGFza09wdGlvbnMob3B0aW9ucywgY29tbWFuZHMgPSBbXSkge1xuICBpZiAoIWZpbHRlclBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKS5yZWR1Y2UoKGNvbW1hbmRzMiwga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKGlzUGF0aFNwZWModmFsdWUpKSB7XG4gICAgICBjb21tYW5kczIucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJQcmltaXRpdmVzKHZhbHVlLCBbXCJib29sZWFuXCJdKSkge1xuICAgICAgY29tbWFuZHMyLnB1c2goa2V5ICsgXCI9XCIgKyB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1hbmRzMi5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kczI7XG4gIH0sIGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIGdldFRyYWlsaW5nT3B0aW9ucyhhcmdzLCBpbml0aWFsUHJpbWl0aXZlID0gMCwgb2JqZWN0T25seSA9IGZhbHNlKSB7XG4gIGNvbnN0IGNvbW1hbmQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGluaXRpYWxQcmltaXRpdmUgPCAwID8gYXJncy5sZW5ndGggOiBpbml0aWFsUHJpbWl0aXZlOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoXCJzdHJpbmd8bnVtYmVyXCIuaW5jbHVkZXModHlwZW9mIGFyZ3NbaV0pKSB7XG4gICAgICBjb21tYW5kLnB1c2goU3RyaW5nKGFyZ3NbaV0pKTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kVGFza09wdGlvbnModHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJncyksIGNvbW1hbmQpO1xuICBpZiAoIW9iamVjdE9ubHkpIHtcbiAgICBjb21tYW5kLnB1c2goLi4udHJhaWxpbmdBcnJheUFyZ3VtZW50KGFyZ3MpKTtcbiAgfVxuICByZXR1cm4gY29tbWFuZDtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzKSB7XG4gIGNvbnN0IGhhc1RyYWlsaW5nQ2FsbGJhY2sgPSB0eXBlb2YgbGFzdChhcmdzKSA9PT0gXCJmdW5jdGlvblwiO1xuICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlckFycmF5LCBbXSk7XG59XG5mdW5jdGlvbiB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmdzKSB7XG4gIGNvbnN0IGhhc1RyYWlsaW5nQ2FsbGJhY2sgPSBmaWx0ZXJGdW5jdGlvbihsYXN0KGFyZ3MpKTtcbiAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJQbGFpbk9iamVjdCk7XG59XG5mdW5jdGlvbiB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJncywgaW5jbHVkZU5vb3AgPSB0cnVlKSB7XG4gIGNvbnN0IGNhbGxiYWNrID0gYXNGdW5jdGlvbihsYXN0KGFyZ3MpKTtcbiAgcmV0dXJuIGluY2x1ZGVOb29wIHx8IGlzVXNlckZ1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogdm9pZCAwO1xufVxudmFyIGluaXRfdGFza19vcHRpb25zID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvdGFzay1vcHRpb25zLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9hcmd1bWVudF9maWx0ZXJzKCk7XG4gICAgaW5pdF91dGlsKCk7XG4gICAgaW5pdF9wYXRoc3BlYygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy90YXNrLXBhcnNlci50c1xuZnVuY3Rpb24gY2FsbFRhc2tQYXJzZXIocGFyc2VyNCwgc3RyZWFtcykge1xuICByZXR1cm4gcGFyc2VyNChzdHJlYW1zLnN0ZE91dCwgc3RyZWFtcy5zdGRFcnIpO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMxMiwgdGV4dHMsIHRyaW0gPSB0cnVlKSB7XG4gIGFzQXJyYXkodGV4dHMpLmZvckVhY2goKHRleHQpID0+IHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IHRvTGluZXNXaXRoQ29udGVudCh0ZXh0LCB0cmltKSwgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gKG9mZnNldCA9IDApID0+IHtcbiAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gbWF4KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lc1tpICsgb2Zmc2V0XTtcbiAgICAgIH07XG4gICAgICBwYXJzZXJzMTIuc29tZSgoeyBwYXJzZSB9KSA9PiBwYXJzZShsaW5lLCByZXN1bHQpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGluaXRfdGFza19wYXJzZXIgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy90YXNrLXBhcnNlci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9pbmRleC50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgRXhpdENvZGVzOiAoKSA9PiBFeGl0Q29kZXMsXG4gIEdpdE91dHB1dFN0cmVhbXM6ICgpID0+IEdpdE91dHB1dFN0cmVhbXMsXG4gIExpbmVQYXJzZXI6ICgpID0+IExpbmVQYXJzZXIsXG4gIE5PT1A6ICgpID0+IE5PT1AsXG4gIE5VTEw6ICgpID0+IE5VTEwsXG4gIFJlbW90ZUxpbmVQYXJzZXI6ICgpID0+IFJlbW90ZUxpbmVQYXJzZXIsXG4gIGFwcGVuZDogKCkgPT4gYXBwZW5kLFxuICBhcHBlbmRUYXNrT3B0aW9uczogKCkgPT4gYXBwZW5kVGFza09wdGlvbnMsXG4gIGFzQXJyYXk6ICgpID0+IGFzQXJyYXksXG4gIGFzQ2FtZWxDYXNlOiAoKSA9PiBhc0NhbWVsQ2FzZSxcbiAgYXNGdW5jdGlvbjogKCkgPT4gYXNGdW5jdGlvbixcbiAgYXNOdW1iZXI6ICgpID0+IGFzTnVtYmVyLFxuICBhc1N0cmluZ0FycmF5OiAoKSA9PiBhc1N0cmluZ0FycmF5LFxuICBidWZmZXJUb1N0cmluZzogKCkgPT4gYnVmZmVyVG9TdHJpbmcsXG4gIGNhbGxUYXNrUGFyc2VyOiAoKSA9PiBjYWxsVGFza1BhcnNlcixcbiAgY3JlYXRlSW5zdGFuY2VDb25maWc6ICgpID0+IGNyZWF0ZUluc3RhbmNlQ29uZmlnLFxuICBkZWxheTogKCkgPT4gZGVsYXksXG4gIGZpbHRlckFycmF5OiAoKSA9PiBmaWx0ZXJBcnJheSxcbiAgZmlsdGVyRnVuY3Rpb246ICgpID0+IGZpbHRlckZ1bmN0aW9uLFxuICBmaWx0ZXJIYXNMZW5ndGg6ICgpID0+IGZpbHRlckhhc0xlbmd0aCxcbiAgZmlsdGVyUGxhaW5PYmplY3Q6ICgpID0+IGZpbHRlclBsYWluT2JqZWN0LFxuICBmaWx0ZXJQcmltaXRpdmVzOiAoKSA9PiBmaWx0ZXJQcmltaXRpdmVzLFxuICBmaWx0ZXJTdHJpbmc6ICgpID0+IGZpbHRlclN0cmluZyxcbiAgZmlsdGVyU3RyaW5nQXJyYXk6ICgpID0+IGZpbHRlclN0cmluZ0FycmF5LFxuICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiAoKSA9PiBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LFxuICBmaWx0ZXJUeXBlOiAoKSA9PiBmaWx0ZXJUeXBlLFxuICBmaXJzdDogKCkgPT4gZmlyc3QsXG4gIGZvbGRlckV4aXN0czogKCkgPT4gZm9sZGVyRXhpc3RzLFxuICBmb3JFYWNoTGluZVdpdGhDb250ZW50OiAoKSA9PiBmb3JFYWNoTGluZVdpdGhDb250ZW50LFxuICBnZXRUcmFpbGluZ09wdGlvbnM6ICgpID0+IGdldFRyYWlsaW5nT3B0aW9ucyxcbiAgaW5jbHVkaW5nOiAoKSA9PiBpbmNsdWRpbmcsXG4gIGlzVXNlckZ1bmN0aW9uOiAoKSA9PiBpc1VzZXJGdW5jdGlvbixcbiAgbGFzdDogKCkgPT4gbGFzdCxcbiAgb2JqZWN0VG9TdHJpbmc6ICgpID0+IG9iamVjdFRvU3RyaW5nLFxuICBvclZvaWQ6ICgpID0+IG9yVm9pZCxcbiAgcGFyc2VTdHJpbmdSZXNwb25zZTogKCkgPT4gcGFyc2VTdHJpbmdSZXNwb25zZSxcbiAgcGljazogKCkgPT4gcGljayxcbiAgcHJlZml4ZWRBcnJheTogKCkgPT4gcHJlZml4ZWRBcnJheSxcbiAgcmVtb3ZlOiAoKSA9PiByZW1vdmUsXG4gIHNwbGl0T246ICgpID0+IHNwbGl0T24sXG4gIHRvTGluZXNXaXRoQ29udGVudDogKCkgPT4gdG9MaW5lc1dpdGhDb250ZW50LFxuICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQ6ICgpID0+IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbiAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQ6ICgpID0+IHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50XG59KTtcbnZhciBpbml0X3V0aWxzID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvaW5kZXgudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2FyZ3VtZW50X2ZpbHRlcnMoKTtcbiAgICBpbml0X2V4aXRfY29kZXMoKTtcbiAgICBpbml0X2dpdF9vdXRwdXRfc3RyZWFtcygpO1xuICAgIGluaXRfbGluZV9wYXJzZXIoKTtcbiAgICBpbml0X3NpbXBsZV9naXRfb3B0aW9ucygpO1xuICAgIGluaXRfdGFza19vcHRpb25zKCk7XG4gICAgaW5pdF90YXNrX3BhcnNlcigpO1xuICAgIGluaXRfdXRpbCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jaGVjay1pcy1yZXBvLnRzXG52YXIgY2hlY2tfaXNfcmVwb19leHBvcnRzID0ge307XG5fX2V4cG9ydChjaGVja19pc19yZXBvX2V4cG9ydHMsIHtcbiAgQ2hlY2tSZXBvQWN0aW9uczogKCkgPT4gQ2hlY2tSZXBvQWN0aW9ucyxcbiAgY2hlY2tJc0JhcmVSZXBvVGFzazogKCkgPT4gY2hlY2tJc0JhcmVSZXBvVGFzayxcbiAgY2hlY2tJc1JlcG9Sb290VGFzazogKCkgPT4gY2hlY2tJc1JlcG9Sb290VGFzayxcbiAgY2hlY2tJc1JlcG9UYXNrOiAoKSA9PiBjaGVja0lzUmVwb1Rhc2tcbn0pO1xuZnVuY3Rpb24gY2hlY2tJc1JlcG9UYXNrKGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbikge1xuICAgIGNhc2UgXCJiYXJlXCIgLyogQkFSRSAqLzpcbiAgICAgIHJldHVybiBjaGVja0lzQmFyZVJlcG9UYXNrKCk7XG4gICAgY2FzZSBcInJvb3RcIiAvKiBJU19SRVBPX1JPT1QgKi86XG4gICAgICByZXR1cm4gY2hlY2tJc1JlcG9Sb290VGFzaygpO1xuICB9XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicmV2LXBhcnNlXCIsIFwiLS1pcy1pbnNpZGUtd29yay10cmVlXCJdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIG9uRXJyb3IsXG4gICAgcGFyc2VyXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0lzUmVwb1Jvb3RUYXNrKCkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCBcIi0tZ2l0LWRpclwiXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBvbkVycm9yLFxuICAgIHBhcnNlcihwYXRoKSB7XG4gICAgICByZXR1cm4gL15cXC4oZ2l0KT8kLy50ZXN0KHBhdGgudHJpbSgpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0lzQmFyZVJlcG9UYXNrKCkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCBcIi0taXMtYmFyZS1yZXBvc2l0b3J5XCJdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIG9uRXJyb3IsXG4gICAgcGFyc2VyXG4gIH07XG59XG5mdW5jdGlvbiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSB7XG4gIHJldHVybiAvKE5vdCBhIGdpdCByZXBvc2l0b3J5fEtlaW4gR2l0LVJlcG9zaXRvcnkpL2kudGVzdChTdHJpbmcoZXJyb3IpKTtcbn1cbnZhciBDaGVja1JlcG9BY3Rpb25zLCBvbkVycm9yLCBwYXJzZXI7XG52YXIgaW5pdF9jaGVja19pc19yZXBvID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY2hlY2staXMtcmVwby50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBDaGVja1JlcG9BY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoQ2hlY2tSZXBvQWN0aW9uczIpID0+IHtcbiAgICAgIENoZWNrUmVwb0FjdGlvbnMyW1wiQkFSRVwiXSA9IFwiYmFyZVwiO1xuICAgICAgQ2hlY2tSZXBvQWN0aW9uczJbXCJJTl9UUkVFXCJdID0gXCJ0cmVlXCI7XG4gICAgICBDaGVja1JlcG9BY3Rpb25zMltcIklTX1JFUE9fUk9PVFwiXSA9IFwicm9vdFwiO1xuICAgICAgcmV0dXJuIENoZWNrUmVwb0FjdGlvbnMyO1xuICAgIH0pKENoZWNrUmVwb0FjdGlvbnMgfHwge30pO1xuICAgIG9uRXJyb3IgPSAoeyBleGl0Q29kZSB9LCBlcnJvciwgZG9uZSwgZmFpbCkgPT4ge1xuICAgICAgaWYgKGV4aXRDb2RlID09PSAxMjggLyogVU5DTEVBTiAqLyAmJiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gZG9uZShCdWZmZXIuZnJvbShcImZhbHNlXCIpKTtcbiAgICAgIH1cbiAgICAgIGZhaWwoZXJyb3IpO1xuICAgIH07XG4gICAgcGFyc2VyID0gKHRleHQpID0+IHtcbiAgICAgIHJldHVybiB0ZXh0LnRyaW0oKSA9PT0gXCJ0cnVlXCI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0NsZWFuU3VtbWFyeS50c1xuZnVuY3Rpb24gY2xlYW5TdW1tYXJ5UGFyc2VyKGRyeVJ1biwgdGV4dCkge1xuICBjb25zdCBzdW1tYXJ5ID0gbmV3IENsZWFuUmVzcG9uc2UoZHJ5UnVuKTtcbiAgY29uc3QgcmVnZXhwID0gZHJ5UnVuID8gZHJ5UnVuUmVtb3ZhbFJlZ2V4cCA6IHJlbW92YWxSZWdleHA7XG4gIHRvTGluZXNXaXRoQ29udGVudCh0ZXh0KS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlZCA9IGxpbmUucmVwbGFjZShyZWdleHAsIFwiXCIpO1xuICAgIHN1bW1hcnkucGF0aHMucHVzaChyZW1vdmVkKTtcbiAgICAoaXNGb2xkZXJSZWdleHAudGVzdChyZW1vdmVkKSA/IHN1bW1hcnkuZm9sZGVycyA6IHN1bW1hcnkuZmlsZXMpLnB1c2gocmVtb3ZlZCk7XG4gIH0pO1xuICByZXR1cm4gc3VtbWFyeTtcbn1cbnZhciBDbGVhblJlc3BvbnNlLCByZW1vdmFsUmVnZXhwLCBkcnlSdW5SZW1vdmFsUmVnZXhwLCBpc0ZvbGRlclJlZ2V4cDtcbnZhciBpbml0X0NsZWFuU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9DbGVhblN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgQ2xlYW5SZXNwb25zZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGRyeVJ1bikge1xuICAgICAgICB0aGlzLmRyeVJ1biA9IGRyeVJ1bjtcbiAgICAgICAgdGhpcy5wYXRocyA9IFtdO1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMuZm9sZGVycyA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVtb3ZhbFJlZ2V4cCA9IC9eW2Etel0rXFxzKi9pO1xuICAgIGRyeVJ1blJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccytbYS16XStcXHMqL2k7XG4gICAgaXNGb2xkZXJSZWdleHAgPSAvXFwvJC87XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3Rhc2sudHNcbnZhciB0YXNrX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRhc2tfZXhwb3J0cywge1xuICBFTVBUWV9DT01NQU5EUzogKCkgPT4gRU1QVFlfQ09NTUFORFMsXG4gIGFkaG9jRXhlY1Rhc2s6ICgpID0+IGFkaG9jRXhlY1Rhc2ssXG4gIGNvbmZpZ3VyYXRpb25FcnJvclRhc2s6ICgpID0+IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssXG4gIGlzQnVmZmVyVGFzazogKCkgPT4gaXNCdWZmZXJUYXNrLFxuICBpc0VtcHR5VGFzazogKCkgPT4gaXNFbXB0eVRhc2ssXG4gIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2s6ICgpID0+IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssXG4gIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2s6ICgpID0+IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2tcbn0pO1xuZnVuY3Rpb24gYWRob2NFeGVjVGFzayhwYXJzZXI0KSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgIGZvcm1hdDogXCJlbXB0eVwiLFxuICAgIHBhcnNlcjogcGFyc2VyNFxuICB9O1xufVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbkVycm9yVGFzayhlcnJvcikge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBFTVBUWV9DT01NQU5EUyxcbiAgICBmb3JtYXQ6IFwiZW1wdHlcIixcbiAgICBwYXJzZXIoKSB7XG4gICAgICB0aHJvdyB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyBuZXcgVGFza0NvbmZpZ3VyYXRpb25FcnJvcihlcnJvcikgOiBlcnJvcjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzLCB0cmltbWVkMiA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiB0cmltbWVkMiA/IFN0cmluZyh0ZXh0KS50cmltKCkgOiB0ZXh0O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwiYnVmZmVyXCIsXG4gICAgcGFyc2VyKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc0J1ZmZlclRhc2sodGFzaykge1xuICByZXR1cm4gdGFzay5mb3JtYXQgPT09IFwiYnVmZmVyXCI7XG59XG5mdW5jdGlvbiBpc0VtcHR5VGFzayh0YXNrKSB7XG4gIHJldHVybiB0YXNrLmZvcm1hdCA9PT0gXCJlbXB0eVwiIHx8ICF0YXNrLmNvbW1hbmRzLmxlbmd0aDtcbn1cbnZhciBFTVBUWV9DT01NQU5EUztcbnZhciBpbml0X3Rhc2sgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy90YXNrLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrX2NvbmZpZ3VyYXRpb25fZXJyb3IoKTtcbiAgICBFTVBUWV9DT01NQU5EUyA9IFtdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jbGVhbi50c1xudmFyIGNsZWFuX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNsZWFuX2V4cG9ydHMsIHtcbiAgQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREU6ICgpID0+IENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFLFxuICBDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRDogKCkgPT4gQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQsXG4gIENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTjogKCkgPT4gQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OLFxuICBDbGVhbk9wdGlvbnM6ICgpID0+IENsZWFuT3B0aW9ucyxcbiAgY2xlYW5UYXNrOiAoKSA9PiBjbGVhblRhc2ssXG4gIGNsZWFuV2l0aE9wdGlvbnNUYXNrOiAoKSA9PiBjbGVhbldpdGhPcHRpb25zVGFzayxcbiAgaXNDbGVhbk9wdGlvbnNBcnJheTogKCkgPT4gaXNDbGVhbk9wdGlvbnNBcnJheVxufSk7XG5mdW5jdGlvbiBjbGVhbldpdGhPcHRpb25zVGFzayhtb2RlLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IHsgY2xlYW5Nb2RlLCBvcHRpb25zLCB2YWxpZCB9ID0gZ2V0Q2xlYW5PcHRpb25zKG1vZGUpO1xuICBpZiAoIWNsZWFuTW9kZSkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEKTtcbiAgfVxuICBpZiAoIXZhbGlkLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gKyBKU09OLnN0cmluZ2lmeShtb2RlKSk7XG4gIH1cbiAgb3B0aW9ucy5wdXNoKC4uLmN1c3RvbUFyZ3MpO1xuICBpZiAob3B0aW9ucy5zb21lKGlzSW50ZXJhY3RpdmVNb2RlKSkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFKTtcbiAgfVxuICByZXR1cm4gY2xlYW5UYXNrKGNsZWFuTW9kZSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjbGVhblRhc2sobW9kZSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNsZWFuXCIsIGAtJHttb2RlfWAsIC4uLmN1c3RvbUFyZ3NdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gY2xlYW5TdW1tYXJ5UGFyc2VyKG1vZGUgPT09IFwiblwiIC8qIERSWV9SVU4gKi8sIHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQ2xlYW5PcHRpb25zQXJyYXkoaW5wdXQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KCh0ZXN0KSA9PiBDbGVhbk9wdGlvblZhbHVlcy5oYXModGVzdCkpO1xufVxuZnVuY3Rpb24gZ2V0Q2xlYW5PcHRpb25zKGlucHV0KSB7XG4gIGxldCBjbGVhbk1vZGU7XG4gIGxldCBvcHRpb25zID0gW107XG4gIGxldCB2YWxpZCA9IHsgY2xlYW5Nb2RlOiBmYWxzZSwgb3B0aW9uczogdHJ1ZSB9O1xuICBpbnB1dC5yZXBsYWNlKC9bXmEtel1pL2csIFwiXCIpLnNwbGl0KFwiXCIpLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICBpZiAoaXNDbGVhbk1vZGUoY2hhcikpIHtcbiAgICAgIGNsZWFuTW9kZSA9IGNoYXI7XG4gICAgICB2YWxpZC5jbGVhbk1vZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZC5vcHRpb25zID0gdmFsaWQub3B0aW9ucyAmJiBpc0tub3duT3B0aW9uKG9wdGlvbnNbb3B0aW9ucy5sZW5ndGhdID0gYC0ke2NoYXJ9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhbk1vZGUsXG4gICAgb3B0aW9ucyxcbiAgICB2YWxpZFxuICB9O1xufVxuZnVuY3Rpb24gaXNDbGVhbk1vZGUoY2xlYW5Nb2RlKSB7XG4gIHJldHVybiBjbGVhbk1vZGUgPT09IFwiZlwiIC8qIEZPUkNFICovIHx8IGNsZWFuTW9kZSA9PT0gXCJuXCIgLyogRFJZX1JVTiAqLztcbn1cbmZ1bmN0aW9uIGlzS25vd25PcHRpb24ob3B0aW9uKSB7XG4gIHJldHVybiAvXi1bYS16XSQvaS50ZXN0KG9wdGlvbikgJiYgQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKG9wdGlvbi5jaGFyQXQoMSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZU1vZGUob3B0aW9uKSB7XG4gIGlmICgvXi1bXlxcLV0vLnRlc3Qob3B0aW9uKSkge1xuICAgIHJldHVybiBvcHRpb24uaW5kZXhPZihcImlcIikgPiAwO1xuICB9XG4gIHJldHVybiBvcHRpb24gPT09IFwiLS1pbnRlcmFjdGl2ZVwiO1xufVxudmFyIENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFLCBDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCwgQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OLCBDbGVhbk9wdGlvbnMsIENsZWFuT3B0aW9uVmFsdWVzO1xudmFyIGluaXRfY2xlYW4gPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jbGVhbi50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQ2xlYW5TdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFID0gXCJHaXQgY2xlYW4gaW50ZXJhY3RpdmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkXCI7XG4gICAgQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQgPSAnR2l0IGNsZWFuIG1vZGUgcGFyYW1ldGVyIChcIm5cIiBvciBcImZcIikgaXMgcmVxdWlyZWQnO1xuICAgIENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTiA9IFwiR2l0IGNsZWFuIHVua25vd24gb3B0aW9uIGZvdW5kIGluOiBcIjtcbiAgICBDbGVhbk9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChDbGVhbk9wdGlvbnMyKSA9PiB7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiRFJZX1JVTlwiXSA9IFwiblwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIkZPUkNFXCJdID0gXCJmXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiSUdOT1JFRF9JTkNMVURFRFwiXSA9IFwieFwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIklHTk9SRURfT05MWVwiXSA9IFwiWFwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIkVYQ0xVRElOR1wiXSA9IFwiZVwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIlFVSUVUXCJdID0gXCJxXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiUkVDVVJTSVZFXCJdID0gXCJkXCI7XG4gICAgICByZXR1cm4gQ2xlYW5PcHRpb25zMjtcbiAgICB9KShDbGVhbk9wdGlvbnMgfHwge30pO1xuICAgIENsZWFuT3B0aW9uVmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgXCJpXCIsXG4gICAgICAuLi5hc1N0cmluZ0FycmF5KE9iamVjdC52YWx1ZXMoQ2xlYW5PcHRpb25zKSlcbiAgICBdKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0NvbmZpZ0xpc3QudHNcbmZ1bmN0aW9uIGNvbmZpZ0xpc3RQYXJzZXIodGV4dCkge1xuICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnTGlzdCgpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnUGFyc2VyKHRleHQpKSB7XG4gICAgY29uZmlnLmFkZFZhbHVlKGl0ZW0uZmlsZSwgU3RyaW5nKGl0ZW0ua2V5KSwgaXRlbS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpIHtcbiAgbGV0IHZhbHVlID0gbnVsbDtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGNvbnN0IHNjb3BlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWdQYXJzZXIodGV4dCwga2V5KSkge1xuICAgIGlmIChpdGVtLmtleSAhPT0ga2V5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWVzLnB1c2godmFsdWUgPSBpdGVtLnZhbHVlKTtcbiAgICBpZiAoIXNjb3Blcy5oYXMoaXRlbS5maWxlKSkge1xuICAgICAgc2NvcGVzLnNldChpdGVtLmZpbGUsIFtdKTtcbiAgICB9XG4gICAgc2NvcGVzLmdldChpdGVtLmZpbGUpLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHBhdGhzOiBBcnJheS5mcm9tKHNjb3Blcy5rZXlzKCkpLFxuICAgIHNjb3BlcyxcbiAgICB2YWx1ZSxcbiAgICB2YWx1ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0ZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gIHJldHVybiBmaWxlUGF0aC5yZXBsYWNlKC9eKGZpbGUpOi8sIFwiXCIpO1xufVxuZnVuY3Rpb24qIGNvbmZpZ1BhcnNlcih0ZXh0LCByZXF1ZXN0ZWRLZXkgPSBudWxsKSB7XG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcMFwiKTtcbiAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPCBtYXg7ICkge1xuICAgIGNvbnN0IGZpbGUgPSBjb25maWdGaWxlUGF0aChsaW5lc1tpKytdKTtcbiAgICBsZXQgdmFsdWUgPSBsaW5lc1tpKytdO1xuICAgIGxldCBrZXkgPSByZXF1ZXN0ZWRLZXk7XG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBsaW5lID0gc3BsaXRPbih2YWx1ZSwgXCJcXG5cIik7XG4gICAgICBrZXkgPSBsaW5lWzBdO1xuICAgICAgdmFsdWUgPSBsaW5lWzFdO1xuICAgIH1cbiAgICB5aWVsZCB7IGZpbGUsIGtleSwgdmFsdWUgfTtcbiAgfVxufVxudmFyIENvbmZpZ0xpc3Q7XG52YXIgaW5pdF9Db25maWdMaXN0ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0NvbmZpZ0xpc3QudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgQ29uZmlnTGlzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICBnZXQgYWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FsbCkge1xuICAgICAgICAgIHRoaXMuX2FsbCA9IHRoaXMuZmlsZXMucmVkdWNlKChhbGwsIGZpbGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFsbCwgdGhpcy52YWx1ZXNbZmlsZV0pO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgICAgfVxuICAgICAgYWRkRmlsZShmaWxlKSB7XG4gICAgICAgIGlmICghKGZpbGUgaW4gdGhpcy52YWx1ZXMpKSB7XG4gICAgICAgICAgY29uc3QgbGF0ZXN0ID0gbGFzdCh0aGlzLmZpbGVzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlc1tmaWxlXSA9IGxhdGVzdCA/IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNbbGF0ZXN0XSkgOiB7fTtcbiAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ZpbGVdO1xuICAgICAgfVxuICAgICAgYWRkVmFsdWUoZmlsZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmFkZEZpbGUoZmlsZSk7XG4gICAgICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSBbdmFsdWVzW2tleV0sIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY29uZmlnLnRzXG5mdW5jdGlvbiBhc0NvbmZpZ1Njb3BlKHNjb3BlLCBmYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSBcInN0cmluZ1wiICYmIEdpdENvbmZpZ1Njb3BlLmhhc093blByb3BlcnR5KHNjb3BlKSkge1xuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICByZXR1cm4gZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBhZGRDb25maWdUYXNrKGtleSwgdmFsdWUsIGFwcGVuZDIsIHNjb3BlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY29uZmlnXCIsIGAtLSR7c2NvcGV9YF07XG4gIGlmIChhcHBlbmQyKSB7XG4gICAgY29tbWFuZHMucHVzaChcIi0tYWRkXCIpO1xuICB9XG4gIGNvbW1hbmRzLnB1c2goa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbmZpZ1Rhc2soa2V5LCBzY29wZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNvbmZpZ1wiLCBcIi0tbnVsbFwiLCBcIi0tc2hvdy1vcmlnaW5cIiwgXCItLWdldC1hbGxcIiwga2V5XTtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIGAtLSR7c2NvcGV9YCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RDb25maWdUYXNrKHNjb3BlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY29uZmlnXCIsIFwiLS1saXN0XCIsIFwiLS1zaG93LW9yaWdpblwiLCBcIi0tbnVsbFwiXTtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29tbWFuZHMucHVzaChgLS0ke3Njb3BlfWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBjb25maWdMaXN0UGFyc2VyKHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ19kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGFkZENvbmZpZyhrZXksIHZhbHVlLCAuLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgYWRkQ29uZmlnVGFzayhcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcmVzdFswXSA9PT0gdHJ1ZSxcbiAgICAgICAgICBhc0NvbmZpZ1Njb3BlKHJlc3RbMV0sIFwibG9jYWxcIiAvKiBsb2NhbCAqLylcbiAgICAgICAgKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRDb25maWcoa2V5LCBzY29wZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGdldENvbmZpZ1Rhc2soa2V5LCBhc0NvbmZpZ1Njb3BlKHNjb3BlLCB2b2lkIDApKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBsaXN0Q29uZmlnKC4uLnJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBsaXN0Q29uZmlnVGFzayhhc0NvbmZpZ1Njb3BlKHJlc3RbMF0sIHZvaWQgMCkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgR2l0Q29uZmlnU2NvcGU7XG52YXIgaW5pdF9jb25maWcgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jb25maWcudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0NvbmZpZ0xpc3QoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgR2l0Q29uZmlnU2NvcGUgPSAvKiBAX19QVVJFX18gKi8gKChHaXRDb25maWdTY29wZTIpID0+IHtcbiAgICAgIEdpdENvbmZpZ1Njb3BlMltcInN5c3RlbVwiXSA9IFwic3lzdGVtXCI7XG4gICAgICBHaXRDb25maWdTY29wZTJbXCJnbG9iYWxcIl0gPSBcImdsb2JhbFwiO1xuICAgICAgR2l0Q29uZmlnU2NvcGUyW1wibG9jYWxcIl0gPSBcImxvY2FsXCI7XG4gICAgICBHaXRDb25maWdTY29wZTJbXCJ3b3JrdHJlZVwiXSA9IFwid29ya3RyZWVcIjtcbiAgICAgIHJldHVybiBHaXRDb25maWdTY29wZTI7XG4gICAgfSkoR2l0Q29uZmlnU2NvcGUgfHwge30pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzLnRzXG5mdW5jdGlvbiBpc0RpZmZOYW1lU3RhdHVzKGlucHV0KSB7XG4gIHJldHVybiBkaWZmTmFtZVN0YXR1cy5oYXMoaW5wdXQpO1xufVxudmFyIERpZmZOYW1lU3RhdHVzLCBkaWZmTmFtZVN0YXR1cztcbnZhciBpbml0X2RpZmZfbmFtZV9zdGF0dXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgRGlmZk5hbWVTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChEaWZmTmFtZVN0YXR1czIpID0+IHtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkFEREVEXCJdID0gXCJBXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJDT1BJRURcIl0gPSBcIkNcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkRFTEVURURcIl0gPSBcIkRcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIk1PRElGSUVEXCJdID0gXCJNXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJSRU5BTUVEXCJdID0gXCJSXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJDSEFOR0VEXCJdID0gXCJUXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJVTk1FUkdFRFwiXSA9IFwiVVwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiVU5LTk9XTlwiXSA9IFwiWFwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiQlJPS0VOXCJdID0gXCJCXCI7XG4gICAgICByZXR1cm4gRGlmZk5hbWVTdGF0dXMyO1xuICAgIH0pKERpZmZOYW1lU3RhdHVzIHx8IHt9KTtcbiAgICBkaWZmTmFtZVN0YXR1cyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhEaWZmTmFtZVN0YXR1cykpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9ncmVwLnRzXG5mdW5jdGlvbiBncmVwUXVlcnlCdWlsZGVyKC4uLnBhcmFtcykge1xuICByZXR1cm4gbmV3IEdyZXBRdWVyeSgpLnBhcmFtKC4uLnBhcmFtcyk7XG59XG5mdW5jdGlvbiBwYXJzZUdyZXAoZ3JlcCkge1xuICBjb25zdCBwYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgZm9yRWFjaExpbmVXaXRoQ29udGVudChncmVwLCAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBbcGF0aCwgbGluZSwgcHJldmlld10gPSBpbnB1dC5zcGxpdChOVUxMKTtcbiAgICBwYXRocy5hZGQocGF0aCk7XG4gICAgKHJlc3VsdHNbcGF0aF0gPSByZXN1bHRzW3BhdGhdIHx8IFtdKS5wdXNoKHtcbiAgICAgIGxpbmU6IGFzTnVtYmVyKGxpbmUpLFxuICAgICAgcGF0aCxcbiAgICAgIHByZXZpZXdcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGF0aHMsXG4gICAgcmVzdWx0c1xuICB9O1xufVxuZnVuY3Rpb24gZ3JlcF9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGdyZXAoc2VhcmNoVGVybSkge1xuICAgICAgY29uc3QgdGhlbiA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGlzYWxsb3dlZE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZXMob3B0aW9uKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmdyZXA6IHVzZSBvZiBcIiR7b3B0aW9ufVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCksXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWFyY2hUZXJtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNlYXJjaFRlcm0gPSBncmVwUXVlcnlCdWlsZGVyKCkucGFyYW0oc2VhcmNoVGVybSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcImdyZXBcIiwgXCItLW51bGxcIiwgXCItblwiLCBcIi0tZnVsbC1uYW1lXCIsIC4uLm9wdGlvbnMsIC4uLnNlYXJjaFRlcm1dO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHtcbiAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgICBwYXJzZXIoc3RkT3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VHcmVwKHN0ZE91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aGVuXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkaXNhbGxvd2VkT3B0aW9ucywgUXVlcnksIF9hLCBHcmVwUXVlcnk7XG52YXIgaW5pdF9ncmVwID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZ3JlcC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBkaXNhbGxvd2VkT3B0aW9ucyA9IFtcIi1oXCJdO1xuICAgIFF1ZXJ5ID0gU3ltYm9sKFwiZ3JlcFF1ZXJ5XCIpO1xuICAgIEdyZXBRdWVyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzW19hXSA9IFtdO1xuICAgICAgfVxuICAgICAgKlsoX2EgPSBRdWVyeSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgdGhpc1tRdWVyeV0pIHtcbiAgICAgICAgICB5aWVsZCBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYW5kKC4uLmFuZCkge1xuICAgICAgICBhbmQubGVuZ3RoICYmIHRoaXNbUXVlcnldLnB1c2goXCItLWFuZFwiLCBcIihcIiwgLi4ucHJlZml4ZWRBcnJheShhbmQsIFwiLWVcIiksIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwYXJhbSguLi5wYXJhbSkge1xuICAgICAgICB0aGlzW1F1ZXJ5XS5wdXNoKC4uLnByZWZpeGVkQXJyYXkocGFyYW0sIFwiLWVcIikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9yZXNldC50c1xudmFyIHJlc2V0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJlc2V0X2V4cG9ydHMsIHtcbiAgUmVzZXRNb2RlOiAoKSA9PiBSZXNldE1vZGUsXG4gIGdldFJlc2V0TW9kZTogKCkgPT4gZ2V0UmVzZXRNb2RlLFxuICByZXNldFRhc2s6ICgpID0+IHJlc2V0VGFza1xufSk7XG5mdW5jdGlvbiByZXNldFRhc2sobW9kZSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJlc2V0XCJdO1xuICBpZiAoaXNWYWxpZFJlc2V0TW9kZShtb2RlKSkge1xuICAgIGNvbW1hbmRzLnB1c2goYC0tJHttb2RlfWApO1xuICB9XG4gIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIGdldFJlc2V0TW9kZShtb2RlKSB7XG4gIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgcmV0dXJuIG1vZGU7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgbW9kZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJzb2Z0XCIgLyogU09GVCAqLztcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpIHtcbiAgcmV0dXJuIFJlc2V0TW9kZXMuaW5jbHVkZXMobW9kZSk7XG59XG52YXIgUmVzZXRNb2RlLCBSZXNldE1vZGVzO1xudmFyIGluaXRfcmVzZXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9yZXNldC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICAgIFJlc2V0TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlc2V0TW9kZTIpID0+IHtcbiAgICAgIFJlc2V0TW9kZTJbXCJNSVhFRFwiXSA9IFwibWl4ZWRcIjtcbiAgICAgIFJlc2V0TW9kZTJbXCJTT0ZUXCJdID0gXCJzb2Z0XCI7XG4gICAgICBSZXNldE1vZGUyW1wiSEFSRFwiXSA9IFwiaGFyZFwiO1xuICAgICAgUmVzZXRNb2RlMltcIk1FUkdFXCJdID0gXCJtZXJnZVwiO1xuICAgICAgUmVzZXRNb2RlMltcIktFRVBcIl0gPSBcImtlZXBcIjtcbiAgICAgIHJldHVybiBSZXNldE1vZGUyO1xuICAgIH0pKFJlc2V0TW9kZSB8fCB7fSk7XG4gICAgUmVzZXRNb2RlcyA9IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhSZXNldE1vZGUpKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvZ2l0LWxvZ2dlci50c1xuaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gY3JlYXRlTG9nKCkge1xuICByZXR1cm4gZGVidWcoXCJzaW1wbGUtZ2l0XCIpO1xufVxuZnVuY3Rpb24gcHJlZml4ZWRMb2dnZXIodG8sIHByZWZpeCwgZm9yd2FyZCkge1xuICBpZiAoIXByZWZpeCB8fCAhU3RyaW5nKHByZWZpeCkucmVwbGFjZSgvXFxzKi8sIFwiXCIpKSB7XG4gICAgcmV0dXJuICFmb3J3YXJkID8gdG8gOiAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICAgICAgdG8obWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgdG8oYCVzICR7bWVzc2FnZX1gLCBwcmVmaXgsIC4uLmFyZ3MpO1xuICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNoaWxkTG9nZ2VyTmFtZShuYW1lLCBjaGlsZERlYnVnZ2VyLCB7IG5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlIH0pIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgY29uc3QgY2hpbGROYW1lc3BhY2UgPSBjaGlsZERlYnVnZ2VyICYmIGNoaWxkRGVidWdnZXIubmFtZXNwYWNlIHx8IFwiXCI7XG4gIGlmIChjaGlsZE5hbWVzcGFjZS5zdGFydHNXaXRoKHBhcmVudE5hbWVzcGFjZSkpIHtcbiAgICByZXR1cm4gY2hpbGROYW1lc3BhY2Uuc3Vic3RyKHBhcmVudE5hbWVzcGFjZS5sZW5ndGggKyAxKTtcbiAgfVxuICByZXR1cm4gY2hpbGROYW1lc3BhY2UgfHwgcGFyZW50TmFtZXNwYWNlO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKGxhYmVsLCB2ZXJib3NlLCBpbml0aWFsU3RlcCwgaW5mb0RlYnVnZ2VyID0gY3JlYXRlTG9nKCkpIHtcbiAgY29uc3QgbGFiZWxQcmVmaXggPSBsYWJlbCAmJiBgWyR7bGFiZWx9XWAgfHwgXCJcIjtcbiAgY29uc3Qgc3Bhd25lZCA9IFtdO1xuICBjb25zdCBkZWJ1Z0RlYnVnZ2VyID0gdHlwZW9mIHZlcmJvc2UgPT09IFwic3RyaW5nXCIgPyBpbmZvRGVidWdnZXIuZXh0ZW5kKHZlcmJvc2UpIDogdmVyYm9zZTtcbiAgY29uc3Qga2V5ID0gY2hpbGRMb2dnZXJOYW1lKGZpbHRlclR5cGUodmVyYm9zZSwgZmlsdGVyU3RyaW5nKSwgZGVidWdEZWJ1Z2dlciwgaW5mb0RlYnVnZ2VyKTtcbiAgcmV0dXJuIHN0ZXAoaW5pdGlhbFN0ZXApO1xuICBmdW5jdGlvbiBzaWJsaW5nKG5hbWUsIGluaXRpYWwpIHtcbiAgICByZXR1cm4gYXBwZW5kKFxuICAgICAgc3Bhd25lZCxcbiAgICAgIGNyZWF0ZUxvZ2dlcihsYWJlbCwga2V5LnJlcGxhY2UoL15bXjpdKy8sIG5hbWUpLCBpbml0aWFsLCBpbmZvRGVidWdnZXIpXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBzdGVwKHBoYXNlKSB7XG4gICAgY29uc3Qgc3RlcFByZWZpeCA9IHBoYXNlICYmIGBbJHtwaGFzZX1dYCB8fCBcIlwiO1xuICAgIGNvbnN0IGRlYnVnMiA9IGRlYnVnRGVidWdnZXIgJiYgcHJlZml4ZWRMb2dnZXIoZGVidWdEZWJ1Z2dlciwgc3RlcFByZWZpeCkgfHwgTk9PUDtcbiAgICBjb25zdCBpbmZvID0gcHJlZml4ZWRMb2dnZXIoaW5mb0RlYnVnZ2VyLCBgJHtsYWJlbFByZWZpeH0gJHtzdGVwUHJlZml4fWAsIGRlYnVnMik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVidWdEZWJ1Z2dlciA/IGRlYnVnMiA6IGluZm8sIHtcbiAgICAgIGxhYmVsLFxuICAgICAgc2libGluZyxcbiAgICAgIGluZm8sXG4gICAgICBzdGVwXG4gICAgfSk7XG4gIH1cbn1cbnZhciBpbml0X2dpdF9sb2dnZXIgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9naXQtbG9nZ2VyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGRlYnVnLmZvcm1hdHRlcnMuTCA9ICh2YWx1ZSkgPT4gU3RyaW5nKGZpbHRlckhhc0xlbmd0aCh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBcIi1cIik7XG4gICAgZGVidWcuZm9ybWF0dGVycy5CID0gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9ydW5uZXJzL3Rhc2tzLXBlbmRpbmctcXVldWUudHNcbnZhciBfVGFza3NQZW5kaW5nUXVldWUsIFRhc2tzUGVuZGluZ1F1ZXVlO1xudmFyIGluaXRfdGFza3NfcGVuZGluZ19xdWV1ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvdGFza3MtcGVuZGluZy1xdWV1ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X2Vycm9yKCk7XG4gICAgaW5pdF9naXRfbG9nZ2VyKCk7XG4gICAgX1Rhc2tzUGVuZGluZ1F1ZXVlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IobG9nTGFiZWwgPSBcIkdpdEV4ZWN1dG9yXCIpIHtcbiAgICAgICAgdGhpcy5sb2dMYWJlbCA9IGxvZ0xhYmVsO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICB3aXRoUHJvZ3Jlc3ModGFzaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZ2V0KHRhc2spO1xuICAgICAgfVxuICAgICAgY3JlYXRlUHJvZ3Jlc3ModGFzaykge1xuICAgICAgICBjb25zdCBuYW1lID0gX1Rhc2tzUGVuZGluZ1F1ZXVlLmdldE5hbWUodGFzay5jb21tYW5kc1swXSk7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih0aGlzLmxvZ0xhYmVsLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBwdXNoKHRhc2spIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLmNyZWF0ZVByb2dyZXNzKHRhc2spO1xuICAgICAgICBwcm9ncmVzcy5sb2dnZXIoXCJBZGRpbmcgdGFzayB0byB0aGUgcXVldWUsIGNvbW1hbmRzID0gJW9cIiwgdGFzay5jb21tYW5kcyk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNldCh0YXNrLCBwcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIGZhdGFsKGVycikge1xuICAgICAgICBmb3IgKGNvbnN0IFt0YXNrLCB7IGxvZ2dlciB9XSBvZiBBcnJheS5mcm9tKHRoaXMuX3F1ZXVlLmVudHJpZXMoKSkpIHtcbiAgICAgICAgICBpZiAodGFzayA9PT0gZXJyLnRhc2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBGYWlsZWQgJW9gLCBlcnIpO1xuICAgICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgICBgRmF0YWwgZXhjZXB0aW9uLCBhbnkgYXMteWV0IHVuLXN0YXJ0ZWQgdGFza3MgcnVuIHRocm91Z2ggdGhpcyBleGVjdXRvciB3aWxsIG5vdCBiZSBhdHRlbXB0ZWRgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYEEgZmF0YWwgZXhjZXB0aW9uIG9jY3VycmVkIGluIGEgcHJldmlvdXMgdGFzaywgdGhlIHF1ZXVlIGhhcyBiZWVuIHB1cmdlZDogJW9gLFxuICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcXVldWUuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVldWUgc2l6ZSBzaG91bGQgYmUgemVybyBhZnRlciBmYXRhbDogJHt0aGlzLl9xdWV1ZS5zaXplfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb21wbGV0ZSh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy53aXRoUHJvZ3Jlc3ModGFzayk7XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXR0ZW1wdCh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy53aXRoUHJvZ3Jlc3ModGFzayk7XG4gICAgICAgIGlmICghcHJvZ3Jlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR2l0RXJyb3Iodm9pZCAwLCBcIlRhc2tzUGVuZGluZ1F1ZXVlOiBhdHRlbXB0IGNhbGxlZCBmb3IgYW4gdW5rbm93biB0YXNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHByb2dyZXNzLmxvZ2dlcihcIlN0YXJ0aW5nIHRhc2tcIik7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBnZXROYW1lKG5hbWUgPSBcImVtcHR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGB0YXNrOiR7bmFtZX06JHsrK19UYXNrc1BlbmRpbmdRdWV1ZS5jb3VudGVyfWA7XG4gICAgICB9XG4gICAgfTtcbiAgICBUYXNrc1BlbmRpbmdRdWV1ZSA9IF9UYXNrc1BlbmRpbmdRdWV1ZTtcbiAgICBUYXNrc1BlbmRpbmdRdWV1ZS5jb3VudGVyID0gMDtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3ItY2hhaW4udHNcbmltcG9ydCB7IHNwYXduIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmZ1bmN0aW9uIHBsdWdpbkNvbnRleHQodGFzaywgY29tbWFuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IGZpcnN0KHRhc2suY29tbWFuZHMpIHx8IFwiXCIsXG4gICAgY29tbWFuZHNcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uRXJyb3JSZWNlaXZlZCh0YXJnZXQsIGxvZ2dlcikge1xuICByZXR1cm4gKGVycikgPT4ge1xuICAgIGxvZ2dlcihgW0VSUk9SXSBjaGlsZCBwcm9jZXNzIGV4Y2VwdGlvbiAlb2AsIGVycik7XG4gICAgdGFyZ2V0LnB1c2goQnVmZmVyLmZyb20oU3RyaW5nKGVyci5zdGFjayksIFwiYXNjaWlcIikpO1xuICB9O1xufVxuZnVuY3Rpb24gb25EYXRhUmVjZWl2ZWQodGFyZ2V0LCBuYW1lLCBsb2dnZXIsIG91dHB1dCkge1xuICByZXR1cm4gKGJ1ZmZlcikgPT4ge1xuICAgIGxvZ2dlcihgJXMgcmVjZWl2ZWQgJUwgYnl0ZXNgLCBuYW1lLCBidWZmZXIpO1xuICAgIG91dHB1dChgJUJgLCBidWZmZXIpO1xuICAgIHRhcmdldC5wdXNoKGJ1ZmZlcik7XG4gIH07XG59XG52YXIgR2l0RXhlY3V0b3JDaGFpbjtcbnZhciBpbml0X2dpdF9leGVjdXRvcl9jaGFpbiA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLWNoYWluLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrc19wZW5kaW5nX3F1ZXVlKCk7XG4gICAgR2l0RXhlY3V0b3JDaGFpbiA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKF9leGVjdXRvciwgX3NjaGVkdWxlciwgX3BsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3IgPSBfZXhlY3V0b3I7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IF9zY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBfcGx1Z2lucztcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgVGFza3NQZW5kaW5nUXVldWUoKTtcbiAgICAgIH1cbiAgICAgIGdldCBjd2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jd2QgfHwgdGhpcy5fZXhlY3V0b3IuY3dkO1xuICAgICAgfVxuICAgICAgc2V0IGN3ZChjd2QpIHtcbiAgICAgICAgdGhpcy5fY3dkID0gY3dkO1xuICAgICAgfVxuICAgICAgZ2V0IGVudigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dG9yLmVudjtcbiAgICAgIH1cbiAgICAgIGdldCBvdXRwdXRIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0b3Iub3V0cHV0SGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGNoYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHB1c2godGFzaykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW4gPSB0aGlzLl9jaGFpbi50aGVuKCgpID0+IHRoaXMuYXR0ZW1wdFRhc2sodGFzaykpO1xuICAgICAgfVxuICAgICAgYXR0ZW1wdFRhc2sodGFzaykge1xuICAgICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNvbnN0IG9uU2NoZWR1bGVDb21wbGV0ZSA9IHlpZWxkIHRoaXMuX3NjaGVkdWxlci5uZXh0KCk7XG4gICAgICAgICAgY29uc3Qgb25RdWV1ZUNvbXBsZXRlID0gKCkgPT4gdGhpcy5fcXVldWUuY29tcGxldGUodGFzayk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9nZ2VyIH0gPSB0aGlzLl9xdWV1ZS5hdHRlbXB0KHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGlzRW1wdHlUYXNrKHRhc2spID8gdGhpcy5hdHRlbXB0RW1wdHlUYXNrKHRhc2ssIGxvZ2dlcikgOiB0aGlzLmF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5vbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBvblF1ZXVlQ29tcGxldGUoKTtcbiAgICAgICAgICAgIG9uU2NoZWR1bGVDb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUpIHtcbiAgICAgICAgY29uc3QgZ2l0RXJyb3IgPSBlIGluc3RhbmNlb2YgR2l0RXJyb3IgPyBPYmplY3QuYXNzaWduKGUsIHsgdGFzayB9KSA6IG5ldyBHaXRFcnJvcih0YXNrLCBlICYmIFN0cmluZyhlKSk7XG4gICAgICAgIHRoaXMuX2NoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZhdGFsKGdpdEVycm9yKTtcbiAgICAgICAgcmV0dXJuIGdpdEVycm9yO1xuICAgICAgfVxuICAgICAgYXR0ZW1wdFJlbW90ZVRhc2sodGFzaywgbG9nZ2VyKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3QgYmluYXJ5ID0gdGhpcy5fcGx1Z2lucy5leGVjKFwic3Bhd24uYmluYXJ5XCIsIFwiXCIsIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcykpO1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXG4gICAgICAgICAgICBcInNwYXduLmFyZ3NcIixcbiAgICAgICAgICAgIFsuLi50YXNrLmNvbW1hbmRzXSxcbiAgICAgICAgICAgIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcylcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHJhdyA9IHlpZWxkIHRoaXMuZ2l0UmVzcG9uc2UoXG4gICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIHRoaXMub3V0cHV0SGFuZGxlcixcbiAgICAgICAgICAgIGxvZ2dlci5zdGVwKFwiU1BBV05cIilcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG91dHB1dFN0cmVhbXMgPSB5aWVsZCB0aGlzLmhhbmRsZVRhc2tEYXRhKHRhc2ssIGFyZ3MsIHJhdywgbG9nZ2VyLnN0ZXAoXCJIQU5ETEVcIikpO1xuICAgICAgICAgIGxvZ2dlcihgcGFzc2luZyByZXNwb25zZSB0byB0YXNrJ3MgcGFyc2VyIGFzIGEgJXNgLCB0YXNrLmZvcm1hdCk7XG4gICAgICAgICAgaWYgKGlzQnVmZmVyVGFzayh0YXNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxUYXNrUGFyc2VyKHRhc2sucGFyc2VyLCBvdXRwdXRTdHJlYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxUYXNrUGFyc2VyKHRhc2sucGFyc2VyLCBvdXRwdXRTdHJlYW1zLmFzU3RyaW5ncygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhdHRlbXB0RW1wdHlUYXNrKHRhc2ssIGxvZ2dlcikge1xuICAgICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGxvZ2dlcihgZW1wdHkgdGFzayBieXBhc3NpbmcgY2hpbGQgcHJvY2VzcyB0byBjYWxsIHRvIHRhc2sncyBwYXJzZXJgKTtcbiAgICAgICAgICByZXR1cm4gdGFzay5wYXJzZXIodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaGFuZGxlVGFza0RhdGEodGFzaywgYXJncywgcmVzdWx0LCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgeyBleGl0Q29kZSwgcmVqZWN0aW9uLCBzdGRPdXQsIHN0ZEVyciB9ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUsIGZhaWwpID0+IHtcbiAgICAgICAgICBsb2dnZXIoYFByZXBhcmluZyB0byBoYW5kbGUgcHJvY2VzcyByZXNwb25zZSBleGl0Q29kZT0lZCBzdGRPdXQ9YCwgZXhpdENvZGUpO1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICAgIFwidGFzay5lcnJvclwiLFxuICAgICAgICAgICAgeyBlcnJvcjogcmVqZWN0aW9uIH0sXG4gICAgICAgICAgICBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgcGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSksIHJlc3VsdClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChlcnJvciAmJiB0YXNrLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBleGl0Q29kZT0lcyBoYW5kbGluZyB3aXRoIGN1c3RvbSBlcnJvciBoYW5kbGVyYCk7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5vbkVycm9yKFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAobmV3U3RkT3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYGN1c3RvbSBlcnJvciBoYW5kbGVyIHRyZWF0ZWQgYXMgc3VjY2Vzc2ApO1xuICAgICAgICAgICAgICAgIGxvZ2dlcihgY3VzdG9tIGVycm9yIHJldHVybmVkIGEgJXNgLCBvYmplY3RUb1N0cmluZyhuZXdTdGRPdXQpKTtcbiAgICAgICAgICAgICAgICBkb25lKFxuICAgICAgICAgICAgICAgICAgbmV3IEdpdE91dHB1dFN0cmVhbXMoXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobmV3U3RkT3V0KSA/IEJ1ZmZlci5jb25jYXQobmV3U3RkT3V0KSA6IG5ld1N0ZE91dCxcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChzdGRFcnIpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZmFpbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYGhhbmRsaW5nIGFzIGVycm9yOiBleGl0Q29kZT0lcyBzdGRFcnI9JXMgcmVqZWN0aW9uPSVvYCxcbiAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgIHN0ZEVyci5sZW5ndGgsXG4gICAgICAgICAgICAgIHJlamVjdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYHJldHJpZXZpbmcgdGFzayBvdXRwdXQgY29tcGxldGVgKTtcbiAgICAgICAgICBkb25lKG5ldyBHaXRPdXRwdXRTdHJlYW1zKEJ1ZmZlci5jb25jYXQoc3RkT3V0KSwgQnVmZmVyLmNvbmNhdChzdGRFcnIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZ2l0UmVzcG9uc2UodGFzaywgY29tbWFuZCwgYXJncywgb3V0cHV0SGFuZGxlciwgbG9nZ2VyKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0TG9nZ2VyID0gbG9nZ2VyLnNpYmxpbmcoXCJvdXRwdXRcIik7XG4gICAgICAgICAgY29uc3Qgc3Bhd25PcHRpb25zID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgICAgXCJzcGF3bi5vcHRpb25zXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICAgIGVudjogdGhpcy5lbnYsXG4gICAgICAgICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGRPdXQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZEVyciA9IFtdO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCVzICVvYCwgY29tbWFuZCwgYXJncyk7XG4gICAgICAgICAgICBsb2dnZXIoXCIlT1wiLCBzcGF3bk9wdGlvbnMpO1xuICAgICAgICAgICAgbGV0IHJlamVjdGlvbiA9IHRoaXMuX2JlZm9yZVNwYXduKHRhc2ssIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlamVjdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZG9uZSh7XG4gICAgICAgICAgICAgICAgc3RkT3V0LFxuICAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgICBleGl0Q29kZTogOTkwMSxcbiAgICAgICAgICAgICAgICByZWplY3Rpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoXCJzcGF3bi5iZWZvcmVcIiwgdm9pZCAwLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpKSwge1xuICAgICAgICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXduZWQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBzcGF3bk9wdGlvbnMpO1xuICAgICAgICAgICAgc3Bhd25lZC5zdGRvdXQub24oXG4gICAgICAgICAgICAgIFwiZGF0YVwiLFxuICAgICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRPdXQsIFwic3RkT3V0XCIsIGxvZ2dlciwgb3V0cHV0TG9nZ2VyLnN0ZXAoXCJzdGRPdXRcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3Bhd25lZC5zdGRlcnIub24oXG4gICAgICAgICAgICAgIFwiZGF0YVwiLFxuICAgICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRFcnIsIFwic3RkRXJyXCIsIGxvZ2dlciwgb3V0cHV0TG9nZ2VyLnN0ZXAoXCJzdGRFcnJcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3Bhd25lZC5vbihcImVycm9yXCIsIG9uRXJyb3JSZWNlaXZlZChzdGRFcnIsIGxvZ2dlcikpO1xuICAgICAgICAgICAgaWYgKG91dHB1dEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyKGBQYXNzaW5nIGNoaWxkIHByb2Nlc3Mgc3RkT3V0L3N0ZEVyciB0byBjdXN0b20gb3V0cHV0SGFuZGxlcmApO1xuICAgICAgICAgICAgICBvdXRwdXRIYW5kbGVyKGNvbW1hbmQsIHNwYXduZWQuc3Rkb3V0LCBzcGF3bmVkLnN0ZGVyciwgWy4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYyhcInNwYXduLmFmdGVyXCIsIHZvaWQgMCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSksIHtcbiAgICAgICAgICAgICAgc3Bhd25lZCxcbiAgICAgICAgICAgICAgY2xvc2UoZXhpdENvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGRvbmUoe1xuICAgICAgICAgICAgICAgICAgc3RkT3V0LFxuICAgICAgICAgICAgICAgICAgc3RkRXJyLFxuICAgICAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgICAgICByZWplY3Rpb246IHJlamVjdGlvbiB8fCByZWFzb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhd25lZC5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uO1xuICAgICAgICAgICAgICAgIHNwYXduZWQua2lsbChcIlNJR0lOVFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIF9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKSB7XG4gICAgICAgIGxldCByZWplY3Rpb247XG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYyhcInNwYXduLmJlZm9yZVwiLCB2b2lkIDAsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHBsdWdpbkNvbnRleHQodGFzaywgYXJncykpLCB7XG4gICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByZWplY3Rpb247XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3IudHNcbnZhciBnaXRfZXhlY3V0b3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZ2l0X2V4ZWN1dG9yX2V4cG9ydHMsIHtcbiAgR2l0RXhlY3V0b3I6ICgpID0+IEdpdEV4ZWN1dG9yXG59KTtcbnZhciBHaXRFeGVjdXRvcjtcbnZhciBpbml0X2dpdF9leGVjdXRvciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXhlY3V0b3JfY2hhaW4oKTtcbiAgICBHaXRFeGVjdXRvciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGN3ZCwgX3NjaGVkdWxlciwgX3BsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5jd2QgPSBjd2Q7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IF9zY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBfcGx1Z2lucztcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuICAgICAgfVxuICAgICAgY2hhaW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuICAgICAgfVxuICAgICAgcHVzaCh0YXNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpbi5wdXNoKHRhc2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2stY2FsbGJhY2sudHNcbmZ1bmN0aW9uIHRhc2tDYWxsYmFjayh0YXNrLCByZXNwb25zZSwgY2FsbGJhY2sgPSBOT09QKSB7XG4gIGNvbnN0IG9uU3VjY2VzcyA9IChkYXRhKSA9PiB7XG4gICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gIH07XG4gIGNvbnN0IG9uRXJyb3IyID0gKGVycikgPT4ge1xuICAgIGlmICgoZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIudGFzaykgPT09IHRhc2spIHtcbiAgICAgIGNhbGxiYWNrKFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBHaXRSZXNwb25zZUVycm9yID8gYWRkRGVwcmVjYXRpb25Ob3RpY2VUb0Vycm9yKGVycikgOiBlcnIsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJlc3BvbnNlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yMik7XG59XG5mdW5jdGlvbiBhZGREZXByZWNhdGlvbk5vdGljZVRvRXJyb3IoZXJyKSB7XG4gIGxldCBsb2cgPSAobmFtZSkgPT4ge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogYWNjZXNzaW5nIEdpdFJlc3BvbnNlRXJyb3IuJHtuYW1lfSBzaG91bGQgYmUgR2l0UmVzcG9uc2VFcnJvci5naXQuJHtuYW1lfSwgdGhpcyB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgaW4gdmVyc2lvbiAzYFxuICAgICk7XG4gICAgbG9nID0gTk9PUDtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZXJyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIuZ2l0KS5yZWR1Y2UoZGVzY3JpcHRvclJlZHVjZXIsIHt9KSk7XG4gIGZ1bmN0aW9uIGRlc2NyaXB0b3JSZWR1Y2VyKGFsbCwgbmFtZSkge1xuICAgIGlmIChuYW1lIGluIGVycikge1xuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG4gICAgYWxsW25hbWVdID0ge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBsb2cobmFtZSk7XG4gICAgICAgIHJldHVybiBlcnIuZ2l0W25hbWVdO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFsbDtcbiAgfVxufVxudmFyIGluaXRfdGFza19jYWxsYmFjayA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2stY2FsbGJhY2sudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9yZXNwb25zZV9lcnJvcigpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hhbmdlLXdvcmtpbmctZGlyZWN0b3J5LnRzXG5mdW5jdGlvbiBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3RvcnksIHJvb3QpIHtcbiAgcmV0dXJuIGFkaG9jRXhlY1Rhc2soKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKCFmb2xkZXJFeGlzdHMoZGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXQuY3dkOiBjYW5ub3QgY2hhbmdlIHRvIG5vbi1kaXJlY3RvcnkgXCIke2RpcmVjdG9yeX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gKHJvb3QgfHwgaW5zdGFuY2UpLmN3ZCA9IGRpcmVjdG9yeTtcbiAgfSk7XG59XG52YXIgaW5pdF9jaGFuZ2Vfd29ya2luZ19kaXJlY3RvcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NoZWNrb3V0LnRzXG5mdW5jdGlvbiBjaGVja291dFRhc2soYXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNoZWNrb3V0XCIsIC4uLmFyZ3NdO1xuICBpZiAoY29tbWFuZHNbMV0gPT09IFwiLWJcIiAmJiBjb21tYW5kcy5pbmNsdWRlcyhcIi1CXCIpKSB7XG4gICAgY29tbWFuZHNbMV0gPSByZW1vdmUoY29tbWFuZHMsIFwiLUJcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gY2hlY2tvdXRfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja291dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja291dFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNoZWNrb3V0QnJhbmNoKGJyYW5jaE5hbWUsIHN0YXJ0UG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja291dFRhc2soW1wiLWJcIiwgYnJhbmNoTmFtZSwgc3RhcnRQb2ludCwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBjaGVja291dExvY2FsQnJhbmNoKGJyYW5jaE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja291dFRhc2soW1wiLWJcIiwgYnJhbmNoTmFtZSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfY2hlY2tvdXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jaGVja291dC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY291bnQtb2JqZWN0cy50c1xuZnVuY3Rpb24gY291bnRPYmplY3RzUmVzcG9uc2UoKSB7XG4gIHJldHVybiB7XG4gICAgY291bnQ6IDAsXG4gICAgZ2FyYmFnZTogMCxcbiAgICBpblBhY2s6IDAsXG4gICAgcGFja3M6IDAsXG4gICAgcHJ1bmVQYWNrYWJsZTogMCxcbiAgICBzaXplOiAwLFxuICAgIHNpemVHYXJiYWdlOiAwLFxuICAgIHNpemVQYWNrOiAwXG4gIH07XG59XG5mdW5jdGlvbiBjb3VudF9vYmplY3RzX2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgY291bnRPYmplY3RzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soe1xuICAgICAgICBjb21tYW5kczogW1wiY291bnQtb2JqZWN0c1wiLCBcIi0tdmVyYm9zZVwiXSxcbiAgICAgICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgICAgIHBhcnNlcihzdGRPdXQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShjb3VudE9iamVjdHNSZXNwb25zZSgpLCBbcGFyc2VyMl0sIHN0ZE91dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBwYXJzZXIyO1xudmFyIGluaXRfY291bnRfb2JqZWN0cyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NvdW50LW9iamVjdHMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcGFyc2VyMiA9IG5ldyBMaW5lUGFyc2VyKFxuICAgICAgLyhbYS16LV0rKTogKFxcZCspJC8sXG4gICAgICAocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBhc0NhbWVsQ2FzZShrZXkpO1xuICAgICAgICBpZiAocmVzdWx0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBhc051bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWNvbW1pdC50c1xuZnVuY3Rpb24gcGFyc2VDb21taXRSZXN1bHQoc3RkT3V0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBhdXRob3I6IG51bGwsXG4gICAgYnJhbmNoOiBcIlwiLFxuICAgIGNvbW1pdDogXCJcIixcbiAgICByb290OiBmYWxzZSxcbiAgICBzdW1tYXJ5OiB7XG4gICAgICBjaGFuZ2VzOiAwLFxuICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgIGRlbGV0aW9uczogMFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UocmVzdWx0LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxudmFyIHBhcnNlcnM7XG52YXIgaW5pdF9wYXJzZV9jb21taXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWNvbW1pdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXJzID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15cXFsoW15cXHNdKykoIFxcKFteKV0rXFwpKT8gKFteXFxdXSspLywgKHJlc3VsdCwgW2JyYW5jaCwgcm9vdCwgY29tbWl0XSkgPT4ge1xuICAgICAgICByZXN1bHQuYnJhbmNoID0gYnJhbmNoO1xuICAgICAgICByZXN1bHQuY29tbWl0ID0gY29tbWl0O1xuICAgICAgICByZXN1bHQucm9vdCA9ICEhcm9vdDtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL1xccypBdXRob3I6XFxzKC4rKS9pLCAocmVzdWx0LCBbYXV0aG9yXSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGF1dGhvci5zcGxpdChcIjxcIik7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFydHMucG9wKCk7XG4gICAgICAgIGlmICghZW1haWwgfHwgIWVtYWlsLmluY2x1ZGVzKFwiQFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuYXV0aG9yID0ge1xuICAgICAgICAgIGVtYWlsOiBlbWFpbC5zdWJzdHIoMCwgZW1haWwubGVuZ3RoIC0gMSksXG4gICAgICAgICAgbmFtZTogcGFydHMuam9pbihcIjxcIikudHJpbSgpXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFxcZCspW14sXSooPzosXFxzKihcXGQrKVteLF0qKSg/OixcXHMqKFxcZCspKS9nLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlcywgaW5zZXJ0aW9ucywgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gcGFyc2VJbnQoaW5zZXJ0aW9ucywgMTApIHx8IDA7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuZGVsZXRpb25zID0gcGFyc2VJbnQoZGVsZXRpb25zLCAxMCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXihcXGQrKVteLF0qKD86LFxccyooXFxkKylbXihdK1xcKChbKy1dKSk/LyxcbiAgICAgICAgKHJlc3VsdCwgW2NoYW5nZXMsIGxpbmVzLCBkaXJlY3Rpb25dKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9IHBhcnNlSW50KGNoYW5nZXMsIDEwKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobGluZXMsIDEwKSB8fCAwO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBjb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jb21taXQudHNcbmZ1bmN0aW9uIGNvbW1pdFRhc2sobWVzc2FnZSwgZmlsZXMsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgXCItY1wiLFxuICAgIFwiY29yZS5hYmJyZXY9NDBcIixcbiAgICBcImNvbW1pdFwiLFxuICAgIC4uLnByZWZpeGVkQXJyYXkobWVzc2FnZSwgXCItbVwiKSxcbiAgICAuLi5maWxlcyxcbiAgICAuLi5jdXN0b21BcmdzXG4gIF07XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZUNvbW1pdFJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gY29tbWl0X2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWl0KG1lc3NhZ2UsIC4uLnJlc3QpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgIGNvbnN0IHRhc2sgPSByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlKSB8fCBjb21taXRUYXNrKFxuICAgICAgICBhc0FycmF5KG1lc3NhZ2UpLFxuICAgICAgICBhc0FycmF5KGZpbHRlclR5cGUocmVzdFswXSwgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSwgW10pKSxcbiAgICAgICAgWy4uLmZpbHRlclR5cGUocmVzdFsxXSwgZmlsdGVyQXJyYXksIFtdKSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSldXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KG1lc3NhZ2UpICYmIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICBgZ2l0LmNvbW1pdDogcmVxdWlyZXMgdGhlIGNvbW1pdCBtZXNzYWdlIHRvIGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nL3N0cmluZ1tdYFxuICAgICk7XG4gIH1cbn1cbnZhciBpbml0X2NvbW1pdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NvbW1pdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGFyc2VfY29tbWl0KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHNcbmZ1bmN0aW9uIGZpcnN0X2NvbW1pdF9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGZpcnN0Q29tbWl0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wicmV2LWxpc3RcIiwgXCItLW1heC1wYXJlbnRzPTBcIiwgXCJIRUFEXCJdLCB0cnVlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfZmlyc3RfY29tbWl0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZmlyc3QtY29tbWl0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50c1xuZnVuY3Rpb24gaGFzaE9iamVjdFRhc2soZmlsZVBhdGgsIHdyaXRlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiaGFzaC1vYmplY3RcIiwgZmlsZVBhdGhdO1xuICBpZiAod3JpdGUpIHtcbiAgICBjb21tYW5kcy5wdXNoKFwiLXdcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMsIHRydWUpO1xufVxudmFyIGluaXRfaGFzaF9vYmplY3QgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvSW5pdFN1bW1hcnkudHNcbmZ1bmN0aW9uIHBhcnNlSW5pdChiYXJlLCBwYXRoLCB0ZXh0KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gU3RyaW5nKHRleHQpLnRyaW0oKTtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKHJlc3VsdCA9IGluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCBmYWxzZSwgcmVzdWx0WzFdKTtcbiAgfVxuICBpZiAocmVzdWx0ID0gcmVJbml0UmVzcG9uc2VSZWdleC5leGVjKHJlc3BvbnNlKSkge1xuICAgIHJldHVybiBuZXcgSW5pdFN1bW1hcnkoYmFyZSwgcGF0aCwgdHJ1ZSwgcmVzdWx0WzFdKTtcbiAgfVxuICBsZXQgZ2l0RGlyID0gXCJcIjtcbiAgY29uc3QgdG9rZW5zID0gcmVzcG9uc2Uuc3BsaXQoXCIgXCIpO1xuICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgaWYgKHRva2VuID09PSBcImluXCIpIHtcbiAgICAgIGdpdERpciA9IHRva2Vucy5qb2luKFwiIFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIC9ecmUvaS50ZXN0KHJlc3BvbnNlKSwgZ2l0RGlyKTtcbn1cbnZhciBJbml0U3VtbWFyeSwgaW5pdFJlc3BvbnNlUmVnZXgsIHJlSW5pdFJlc3BvbnNlUmVnZXg7XG52YXIgaW5pdF9Jbml0U3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIEluaXRTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYmFyZSwgcGF0aCwgZXhpc3RpbmcsIGdpdERpcikge1xuICAgICAgICB0aGlzLmJhcmUgPSBiYXJlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmV4aXN0aW5nID0gZXhpc3Rpbmc7XG4gICAgICAgIHRoaXMuZ2l0RGlyID0gZ2l0RGlyO1xuICAgICAgfVxuICAgIH07XG4gICAgaW5pdFJlc3BvbnNlUmVnZXggPSAvXkluaXQuKyByZXBvc2l0b3J5IGluICguKykkLztcbiAgICByZUluaXRSZXNwb25zZVJlZ2V4ID0gL15SZWluLisgaW4gKC4rKSQvO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9pbml0LnRzXG5mdW5jdGlvbiBoYXNCYXJlQ29tbWFuZChjb21tYW5kKSB7XG4gIHJldHVybiBjb21tYW5kLmluY2x1ZGVzKGJhcmVDb21tYW5kKTtcbn1cbmZ1bmN0aW9uIGluaXRUYXNrKGJhcmUgPSBmYWxzZSwgcGF0aCwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImluaXRcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChiYXJlICYmICFoYXNCYXJlQ29tbWFuZChjb21tYW5kcykpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYmFyZUNvbW1hbmQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZUluaXQoY29tbWFuZHMuaW5jbHVkZXMoXCItLWJhcmVcIiksIHBhdGgsIHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBiYXJlQ29tbWFuZDtcbnZhciBpbml0X2luaXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9pbml0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9Jbml0U3VtbWFyeSgpO1xuICAgIGJhcmVDb21tYW5kID0gXCItLWJhcmVcIjtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXJncy9sb2ctZm9ybWF0LnRzXG5mdW5jdGlvbiBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tQXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZvcm1hdCA9IGxvZ0Zvcm1hdFJlZ2V4LmV4ZWMoY3VzdG9tQXJnc1tpXSk7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGAtLSR7Zm9ybWF0WzFdfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiIC8qIE5PTkUgKi87XG59XG5mdW5jdGlvbiBpc0xvZ0Zvcm1hdChjdXN0b21BcmcpIHtcbiAgcmV0dXJuIGxvZ0Zvcm1hdFJlZ2V4LnRlc3QoY3VzdG9tQXJnKTtcbn1cbnZhciBsb2dGb3JtYXRSZWdleDtcbnZhciBpbml0X2xvZ19mb3JtYXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBsb2dGb3JtYXRSZWdleCA9IC9eLS0oc3RhdHxudW1zdGF0fG5hbWUtb25seXxuYW1lLXN0YXR1cykoPXwkKS87XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9EaWZmU3VtbWFyeS50c1xudmFyIERpZmZTdW1tYXJ5O1xudmFyIGluaXRfRGlmZlN1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvRGlmZlN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBEaWZmU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSAwO1xuICAgICAgICB0aGlzLmRlbGV0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuaW5zZXJ0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWRpZmYtc3VtbWFyeS50c1xuZnVuY3Rpb24gZ2V0RGlmZlBhcnNlcihmb3JtYXQgPSBcIlwiIC8qIE5PTkUgKi8pIHtcbiAgY29uc3QgcGFyc2VyNCA9IGRpZmZTdW1tYXJ5UGFyc2Vyc1tmb3JtYXRdO1xuICByZXR1cm4gKHN0ZE91dCkgPT4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgRGlmZlN1bW1hcnkoKSwgcGFyc2VyNCwgc3RkT3V0LCBmYWxzZSk7XG59XG52YXIgc3RhdFBhcnNlciwgbnVtU3RhdFBhcnNlciwgbmFtZU9ubHlQYXJzZXIsIG5hbWVTdGF0dXNQYXJzZXIsIGRpZmZTdW1tYXJ5UGFyc2VycztcbnZhciBpbml0X3BhcnNlX2RpZmZfc3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9EaWZmU3VtbWFyeSgpO1xuICAgIGluaXRfZGlmZl9uYW1lX3N0YXR1cygpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBzdGF0UGFyc2VyID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKC4rKVxccytcXHxcXHMrKFxcZCspKFxccytbK1xcLV0rKT8kLyxcbiAgICAgICAgKHJlc3VsdCwgW2ZpbGUsIGNoYW5nZXMsIGFsdGVyYXRpb25zID0gXCJcIl0pID0+IHtcbiAgICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGFzTnVtYmVyKGNoYW5nZXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14rXS9nLCBcIlwiKS5sZW5ndGgsXG4gICAgICAgICAgICBkZWxldGlvbnM6IGFsdGVyYXRpb25zLnJlcGxhY2UoL1teLV0vZywgXCJcIikubGVuZ3RoLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKC4rKSBcXHxcXHMrQmluIChbMC05Ll0rKSAtPiAoWzAtOS5dKykgKFthLXpdKykvLFxuICAgICAgICAocmVzdWx0LCBbZmlsZSwgYmVmb3JlLCBhZnRlcl0pID0+IHtcbiAgICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGJlZm9yZTogYXNOdW1iZXIoYmVmb3JlKSxcbiAgICAgICAgICAgIGFmdGVyOiBhc051bWJlcihhZnRlciksXG4gICAgICAgICAgICBiaW5hcnk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFxcZCspIGZpbGVzPyBjaGFuZ2VkXFxzKigoPzosIFxcZCsgW14sXSspezAsMn0pLyxcbiAgICAgICAgKHJlc3VsdCwgW2NoYW5nZWQsIHN1bW1hcnldKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSAvKFxcZCspIGkvLmV4ZWMoc3VtbWFyeSk7XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IC8oXFxkKykgZC8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgICByZXN1bHQuY2hhbmdlZCA9IGFzTnVtYmVyKGNoYW5nZWQpO1xuICAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zID0gYXNOdW1iZXIoaW5zZXJ0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGluc2VydGVkWzFdKTtcbiAgICAgICAgICByZXN1bHQuZGVsZXRpb25zID0gYXNOdW1iZXIoZGVsZXRlZCA9PSBudWxsID8gdm9pZCAwIDogZGVsZXRlZFsxXSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICAgIG51bVN0YXRQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgLyhcXGQrKVxcdChcXGQrKVxcdCguKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2NoYW5nZXNJbnNlcnQsIGNoYW5nZXNEZWxldGUsIGZpbGVdKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNJbnNlcnQpO1xuICAgICAgICAgIGNvbnN0IGRlbGV0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNEZWxldGUpO1xuICAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnMgKz0gaW5zZXJ0aW9ucztcbiAgICAgICAgICByZXN1bHQuZGVsZXRpb25zICs9IGRlbGV0aW9ucztcbiAgICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgY2hhbmdlczogaW5zZXJ0aW9ucyArIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGluc2VydGlvbnMsXG4gICAgICAgICAgICBkZWxldGlvbnMsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcigvLVxcdC1cXHQoLispJC8sIChyZXN1bHQsIFtmaWxlXSkgPT4ge1xuICAgICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBhZnRlcjogMCxcbiAgICAgICAgICBiZWZvcmU6IDAsXG4gICAgICAgICAgYmluYXJ5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICBdO1xuICAgIG5hbWVPbmx5UGFyc2VyID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoLyguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICAgICAgYmluYXJ5OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgXTtcbiAgICBuYW1lU3RhdHVzUGFyc2VyID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oW0FDRE1SVFVYQl0pKFswLTldezAsM30pXFx0KC5bXlxcdF0qKShcXHQoLlteXFx0XSopKT8kLyxcbiAgICAgICAgKHJlc3VsdCwgW3N0YXR1cywgc2ltaWxhcml0eSwgZnJvbSwgX3RvLCB0b10pID0+IHtcbiAgICAgICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IHRvICE9IG51bGwgPyB0byA6IGZyb20sXG4gICAgICAgICAgICBjaGFuZ2VzOiAwLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6IG9yVm9pZChpc0RpZmZOYW1lU3RhdHVzKHN0YXR1cykgJiYgc3RhdHVzKSxcbiAgICAgICAgICAgIGZyb206IG9yVm9pZCghIXRvICYmIGZyb20gIT09IHRvICYmIGZyb20pLFxuICAgICAgICAgICAgc2ltaWxhcml0eTogYXNOdW1iZXIoc2ltaWxhcml0eSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgZGlmZlN1bW1hcnlQYXJzZXJzID0ge1xuICAgICAgW1wiXCIgLyogTk9ORSAqL106IHN0YXRQYXJzZXIsXG4gICAgICBbXCItLXN0YXRcIiAvKiBTVEFUICovXTogc3RhdFBhcnNlcixcbiAgICAgIFtcIi0tbnVtc3RhdFwiIC8qIE5VTV9TVEFUICovXTogbnVtU3RhdFBhcnNlcixcbiAgICAgIFtcIi0tbmFtZS1zdGF0dXNcIiAvKiBOQU1FX1NUQVRVUyAqL106IG5hbWVTdGF0dXNQYXJzZXIsXG4gICAgICBbXCItLW5hbWUtb25seVwiIC8qIE5BTUVfT05MWSAqL106IG5hbWVPbmx5UGFyc2VyXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1saXN0LWxvZy1zdW1tYXJ5LnRzXG5mdW5jdGlvbiBsaW5lQnVpbGRlcih0b2tlbnMsIGZpZWxkcykge1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShcbiAgICAobGluZSwgZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICBsaW5lW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUoeyBkaWZmOiBudWxsIH0pXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciA9IFNQTElUVEVSLCBmaWVsZHMgPSBkZWZhdWx0RmllbGROYW1lcywgbG9nRm9ybWF0ID0gXCJcIiAvKiBOT05FICovKSB7XG4gIGNvbnN0IHBhcnNlRGlmZlJlc3VsdCA9IGdldERpZmZQYXJzZXIobG9nRm9ybWF0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0ZE91dCkge1xuICAgIGNvbnN0IGFsbCA9IHRvTGluZXNXaXRoQ29udGVudChcbiAgICAgIHN0ZE91dC50cmltKCksXG4gICAgICBmYWxzZSxcbiAgICAgIFNUQVJUX0JPVU5EQVJZXG4gICAgKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgY29uc3QgbGluZURldGFpbCA9IGl0ZW0uc3BsaXQoQ09NTUlUX0JPVU5EQVJZKTtcbiAgICAgIGNvbnN0IGxpc3RMb2dMaW5lID0gbGluZUJ1aWxkZXIobGluZURldGFpbFswXS5zcGxpdChzcGxpdHRlciksIGZpZWxkcyk7XG4gICAgICBpZiAobGluZURldGFpbC5sZW5ndGggPiAxICYmICEhbGluZURldGFpbFsxXS50cmltKCkpIHtcbiAgICAgICAgbGlzdExvZ0xpbmUuZGlmZiA9IHBhcnNlRGlmZlJlc3VsdChsaW5lRGV0YWlsWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0TG9nTGluZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYWxsLFxuICAgICAgbGF0ZXN0OiBhbGwubGVuZ3RoICYmIGFsbFswXSB8fCBudWxsLFxuICAgICAgdG90YWw6IGFsbC5sZW5ndGhcbiAgICB9O1xuICB9O1xufVxudmFyIFNUQVJUX0JPVU5EQVJZLCBDT01NSVRfQk9VTkRBUlksIFNQTElUVEVSLCBkZWZhdWx0RmllbGROYW1lcztcbnZhciBpbml0X3BhcnNlX2xpc3RfbG9nX3N1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWxpc3QtbG9nLXN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9kaWZmX3N1bW1hcnkoKTtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBTVEFSVF9CT1VOREFSWSA9IFwiXFx4RjJcXHhGMlxceEYyXFx4RjJcXHhGMlxceEYyIFwiO1xuICAgIENPTU1JVF9CT1VOREFSWSA9IFwiIFxceEYyXFx4RjJcIjtcbiAgICBTUExJVFRFUiA9IFwiIFxceEYyIFwiO1xuICAgIGRlZmF1bHRGaWVsZE5hbWVzID0gW1wiaGFzaFwiLCBcImRhdGVcIiwgXCJtZXNzYWdlXCIsIFwicmVmc1wiLCBcImF1dGhvcl9uYW1lXCIsIFwiYXV0aG9yX2VtYWlsXCJdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9kaWZmLnRzXG52YXIgZGlmZl9leHBvcnRzID0ge307XG5fX2V4cG9ydChkaWZmX2V4cG9ydHMsIHtcbiAgZGlmZlN1bW1hcnlUYXNrOiAoKSA9PiBkaWZmU3VtbWFyeVRhc2ssXG4gIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnOiAoKSA9PiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZ1xufSk7XG5mdW5jdGlvbiBkaWZmU3VtbWFyeVRhc2soY3VzdG9tQXJncykge1xuICBsZXQgbG9nRm9ybWF0ID0gbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJncyk7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiZGlmZlwiXTtcbiAgaWYgKGxvZ0Zvcm1hdCA9PT0gXCJcIiAvKiBOT05FICovKSB7XG4gICAgbG9nRm9ybWF0ID0gXCItLXN0YXRcIiAvKiBTVEFUICovO1xuICAgIGNvbW1hbmRzLnB1c2goXCItLXN0YXQ9NDA5NlwiKTtcbiAgfVxuICBjb21tYW5kcy5wdXNoKC4uLmN1c3RvbUFyZ3MpO1xuICByZXR1cm4gdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IGdldERpZmZQYXJzZXIobG9nRm9ybWF0KVxuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY3VzdG9tQXJncykge1xuICBjb25zdCBmbGFncyA9IGN1c3RvbUFyZ3MuZmlsdGVyKGlzTG9nRm9ybWF0KTtcbiAgaWYgKGZsYWdzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBTdW1tYXJ5IGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgLSBwaWNrIG9uZSBvZiAke2ZsYWdzLmpvaW4oXCIsXCIpfWBcbiAgICApO1xuICB9XG4gIGlmIChmbGFncy5sZW5ndGggJiYgY3VzdG9tQXJncy5pbmNsdWRlcyhcIi16XCIpKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICBgU3VtbWFyeSBmbGFnICR7ZmxhZ3N9IHBhcnNpbmcgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBudWxsIHRlcm1pbmF0aW9uIG9wdGlvbiAnLXonYFxuICAgICk7XG4gIH1cbn1cbnZhciBpbml0X2RpZmYgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9kaWZmLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9wYXJzZV9kaWZmX3N1bW1hcnkoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvbG9nLnRzXG5mdW5jdGlvbiBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcikge1xuICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgY29uc3QgZm9ybWF0U3RyID0gW107XG4gIE9iamVjdC5rZXlzKGZvcm1hdCkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBmaWVsZHMucHVzaChmaWVsZCk7XG4gICAgZm9ybWF0U3RyLnB1c2goU3RyaW5nKGZvcm1hdFtmaWVsZF0pKTtcbiAgfSk7XG4gIHJldHVybiBbZmllbGRzLCBmb3JtYXRTdHIuam9pbihzcGxpdHRlcildO1xufVxuZnVuY3Rpb24gdXNlck9wdGlvbnMoaW5wdXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KS5yZWR1Y2UoKG91dCwga2V5KSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIGV4Y2x1ZGVPcHRpb25zKSkge1xuICAgICAgb3V0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwYXJzZUxvZ09wdGlvbnMob3B0ID0ge30sIGN1c3RvbUFyZ3MgPSBbXSkge1xuICBjb25zdCBzcGxpdHRlciA9IGZpbHRlclR5cGUob3B0LnNwbGl0dGVyLCBmaWx0ZXJTdHJpbmcsIFNQTElUVEVSKTtcbiAgY29uc3QgZm9ybWF0ID0gIWZpbHRlclByaW1pdGl2ZXMob3B0LmZvcm1hdCkgJiYgb3B0LmZvcm1hdCA/IG9wdC5mb3JtYXQgOiB7XG4gICAgaGFzaDogXCIlSFwiLFxuICAgIGRhdGU6IG9wdC5zdHJpY3REYXRlID09PSBmYWxzZSA/IFwiJWFpXCIgOiBcIiVhSVwiLFxuICAgIG1lc3NhZ2U6IFwiJXNcIixcbiAgICByZWZzOiBcIiVEXCIsXG4gICAgYm9keTogb3B0Lm11bHRpTGluZSA/IFwiJUJcIiA6IFwiJWJcIixcbiAgICBhdXRob3JfbmFtZTogb3B0Lm1haWxNYXAgIT09IGZhbHNlID8gXCIlYU5cIiA6IFwiJWFuXCIsXG4gICAgYXV0aG9yX2VtYWlsOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyBcIiVhRVwiIDogXCIlYWVcIlxuICB9O1xuICBjb25zdCBbZmllbGRzLCBmb3JtYXRTdHJdID0gcHJldHR5Rm9ybWF0KGZvcm1hdCwgc3BsaXR0ZXIpO1xuICBjb25zdCBzdWZmaXggPSBbXTtcbiAgY29uc3QgY29tbWFuZCA9IFtcbiAgICBgLS1wcmV0dHk9Zm9ybWF0OiR7U1RBUlRfQk9VTkRBUll9JHtmb3JtYXRTdHJ9JHtDT01NSVRfQk9VTkRBUll9YCxcbiAgICAuLi5jdXN0b21BcmdzXG4gIF07XG4gIGNvbnN0IG1heENvdW50ID0gb3B0Lm4gfHwgb3B0W1wibWF4LWNvdW50XCJdIHx8IG9wdC5tYXhDb3VudDtcbiAgaWYgKG1heENvdW50KSB7XG4gICAgY29tbWFuZC5wdXNoKGAtLW1heC1jb3VudD0ke21heENvdW50fWApO1xuICB9XG4gIGlmIChvcHQuZnJvbSB8fCBvcHQudG8pIHtcbiAgICBjb25zdCByYW5nZU9wZXJhdG9yID0gb3B0LnN5bW1ldHJpYyAhPT0gZmFsc2UgPyBcIi4uLlwiIDogXCIuLlwiO1xuICAgIHN1ZmZpeC5wdXNoKGAke29wdC5mcm9tIHx8IFwiXCJ9JHtyYW5nZU9wZXJhdG9yfSR7b3B0LnRvIHx8IFwiXCJ9YCk7XG4gIH1cbiAgaWYgKGZpbHRlclN0cmluZyhvcHQuZmlsZSkpIHtcbiAgICBjb21tYW5kLnB1c2goXCItLWZvbGxvd1wiLCBwYXRoc3BlYyhvcHQuZmlsZSkpO1xuICB9XG4gIGFwcGVuZFRhc2tPcHRpb25zKHVzZXJPcHRpb25zKG9wdCksIGNvbW1hbmQpO1xuICByZXR1cm4ge1xuICAgIGZpZWxkcyxcbiAgICBzcGxpdHRlcixcbiAgICBjb21tYW5kczogWy4uLmNvbW1hbmQsIC4uLnN1ZmZpeF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ1Rhc2soc3BsaXR0ZXIsIGZpZWxkcywgY3VzdG9tQXJncykge1xuICBjb25zdCBwYXJzZXI0ID0gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXIoc3BsaXR0ZXIsIGZpZWxkcywgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJncykpO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBbXCJsb2dcIiwgLi4uY3VzdG9tQXJnc10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZXI0XG4gIH07XG59XG5mdW5jdGlvbiBsb2dfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2coLi4ucmVzdCkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlTG9nT3B0aW9ucyhcbiAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSxcbiAgICAgICAgZmlsdGVyVHlwZShhcmd1bWVudHNbMF0sIGZpbHRlckFycmF5KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRhc2sgPSByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyguLi5yZXN0KSB8fCB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhvcHRpb25zLmNvbW1hbmRzKSB8fCBjcmVhdGVMb2dUYXNrKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjcmVhdGVMb2dUYXNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbG9nVGFzayhvcHRpb25zLnNwbGl0dGVyLCBvcHRpb25zLmZpZWxkcywgb3B0aW9ucy5jb21tYW5kcyk7XG4gIH1cbiAgZnVuY3Rpb24gcmVqZWN0RGVwcmVjYXRlZFNpZ25hdHVyZXMoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gZmlsdGVyU3RyaW5nKGZyb20pICYmIGZpbHRlclN0cmluZyh0bykgJiYgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBnaXQubG9nKHN0cmluZywgc3RyaW5nKSBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBnaXQubG9nKHsgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nIH0pYFxuICAgICk7XG4gIH1cbn1cbnZhciBleGNsdWRlT3B0aW9ucztcbnZhciBpbml0X2xvZyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2xvZy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfbG9nX2Zvcm1hdCgpO1xuICAgIGluaXRfcGF0aHNwZWMoKTtcbiAgICBpbml0X3BhcnNlX2xpc3RfbG9nX3N1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgaW5pdF9kaWZmKCk7XG4gICAgZXhjbHVkZU9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChleGNsdWRlT3B0aW9uczIpID0+IHtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCItLXByZXR0eVwiXSA9IDBdID0gXCItLXByZXR0eVwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm1heC1jb3VudFwiXSA9IDFdID0gXCJtYXgtY291bnRcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJtYXhDb3VudFwiXSA9IDJdID0gXCJtYXhDb3VudFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm5cIl0gPSAzXSA9IFwiblwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcImZpbGVcIl0gPSA0XSA9IFwiZmlsZVwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcImZvcm1hdFwiXSA9IDVdID0gXCJmb3JtYXRcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJmcm9tXCJdID0gNl0gPSBcImZyb21cIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJ0b1wiXSA9IDddID0gXCJ0b1wiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcInNwbGl0dGVyXCJdID0gOF0gPSBcInNwbGl0dGVyXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wic3ltbWV0cmljXCJdID0gOV0gPSBcInN5bW1ldHJpY1wiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm1haWxNYXBcIl0gPSAxMF0gPSBcIm1haWxNYXBcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJtdWx0aUxpbmVcIl0gPSAxMV0gPSBcIm11bHRpTGluZVwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcInN0cmljdERhdGVcIl0gPSAxMl0gPSBcInN0cmljdERhdGVcIjtcbiAgICAgIHJldHVybiBleGNsdWRlT3B0aW9uczI7XG4gICAgfSkoZXhjbHVkZU9wdGlvbnMgfHwge30pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5LnRzXG52YXIgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QsIE1lcmdlU3VtbWFyeURldGFpbDtcbnZhciBpbml0X01lcmdlU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9NZXJnZVN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBNZXJnZVN1bW1hcnlDb25mbGljdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJlYXNvbiwgZmlsZSA9IG51bGwsIG1ldGEpIHtcbiAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZmlsZX06JHt0aGlzLnJlYXNvbn1gO1xuICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VTdW1tYXJ5RGV0YWlsID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29uZmxpY3RzID0gW107XG4gICAgICAgIHRoaXMubWVyZ2VzID0gW107XG4gICAgICAgIHRoaXMucmVzdWx0ID0gXCJzdWNjZXNzXCI7XG4gICAgICB9XG4gICAgICBnZXQgZmFpbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25mbGljdHMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICAgIGdldCByZWFzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5jb25mbGljdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGBDT05GTElDVFM6ICR7dGhpcy5jb25mbGljdHMuam9pbihcIiwgXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiT0tcIjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvUHVsbFN1bW1hcnkudHNcbnZhciBQdWxsU3VtbWFyeSwgUHVsbEZhaWxlZFN1bW1hcnk7XG52YXIgaW5pdF9QdWxsU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFB1bGxTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVtb3RlTWVzc2FnZXMgPSB7XG4gICAgICAgICAgYWxsOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxldGVkID0gW107XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxldGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5pbnNlcnRpb25zID0ge307XG4gICAgICAgIHRoaXMuc3VtbWFyeSA9IHtcbiAgICAgICAgICBjaGFuZ2VzOiAwLFxuICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICBpbnNlcnRpb25zOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBQdWxsRmFpbGVkU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlbW90ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuaGFzaCA9IHtcbiAgICAgICAgICBsb2NhbDogXCJcIixcbiAgICAgICAgICByZW1vdGU6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5icmFuY2ggPSB7XG4gICAgICAgICAgbG9jYWw6IFwiXCIsXG4gICAgICAgICAgcmVtb3RlOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IFwiXCI7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1vYmplY3RzLnRzXG5mdW5jdGlvbiBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZW1vdGVNZXNzYWdlcykge1xuICByZXR1cm4gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyA9IHJlbW90ZU1lc3NhZ2VzLm9iamVjdHMgfHwge1xuICAgIGNvbXByZXNzaW5nOiAwLFxuICAgIGNvdW50aW5nOiAwLFxuICAgIGVudW1lcmF0aW5nOiAwLFxuICAgIHBhY2tSZXVzZWQ6IDAsXG4gICAgcmV1c2VkOiB7IGNvdW50OiAwLCBkZWx0YTogMCB9LFxuICAgIHRvdGFsOiB7IGNvdW50OiAwLCBkZWx0YTogMCB9XG4gIH07XG59XG5mdW5jdGlvbiBhc09iamVjdENvdW50KHNvdXJjZSkge1xuICBjb25zdCBjb3VudCA9IC9eXFxzKihcXGQrKS8uZXhlYyhzb3VyY2UpO1xuICBjb25zdCBkZWx0YSA9IC9kZWx0YSAoXFxkKykvaS5leGVjKHNvdXJjZSk7XG4gIHJldHVybiB7XG4gICAgY291bnQ6IGFzTnVtYmVyKGNvdW50ICYmIGNvdW50WzFdIHx8IFwiMFwiKSxcbiAgICBkZWx0YTogYXNOdW1iZXIoZGVsdGEgJiYgZGVsdGFbMV0gfHwgXCIwXCIpXG4gIH07XG59XG52YXIgcmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzO1xudmFyIGluaXRfcGFyc2VfcmVtb3RlX29iamVjdHMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1vYmplY3RzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycyA9IFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAvXnJlbW90ZTpcXHMqKGVudW1lcmF0aW5nfGNvdW50aW5nfGNvbXByZXNzaW5nKSBvYmplY3RzOiAoXFxkKyksL2ksXG4gICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGNvbnN0IGVudW1lcmF0aW9uID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGVudW1lcmF0aW9uLCB7IFtrZXldOiBhc051bWJlcihjb3VudCkgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgL15yZW1vdGU6XFxzKihlbnVtZXJhdGluZ3xjb3VudGluZ3xjb21wcmVzc2luZykgb2JqZWN0czogXFxkKyUgXFwoXFxkK1xcLyhcXGQrKVxcKSwvaSxcbiAgICAgICAgKHJlc3VsdCwgW2FjdGlvbiwgY291bnRdKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAvdG90YWwgKFteLF0rKSwgcmV1c2VkIChbXixdKyksIHBhY2stcmV1c2VkIChcXGQrKS9pLFxuICAgICAgICAocmVzdWx0LCBbdG90YWwsIHJldXNlZCwgcGFja1JldXNlZF0pID0+IHtcbiAgICAgICAgICBjb25zdCBvYmplY3RzID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICBvYmplY3RzLnRvdGFsID0gYXNPYmplY3RDb3VudCh0b3RhbCk7XG4gICAgICAgICAgb2JqZWN0cy5yZXVzZWQgPSBhc09iamVjdENvdW50KHJldXNlZCk7XG4gICAgICAgICAgb2JqZWN0cy5wYWNrUmV1c2VkID0gYXNOdW1iZXIocGFja1JldXNlZCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gcGFyc2VSZW1vdGVNZXNzYWdlcyhfc3RkT3V0LCBzdGRFcnIpIHtcbiAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UoeyByZW1vdGVNZXNzYWdlczogbmV3IFJlbW90ZU1lc3NhZ2VTdW1tYXJ5KCkgfSwgcGFyc2VyczIsIHN0ZEVycik7XG59XG52YXIgcGFyc2VyczIsIFJlbW90ZU1lc3NhZ2VTdW1tYXJ5O1xudmFyIGluaXRfcGFyc2VfcmVtb3RlX21lc3NhZ2VzID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtbWVzc2FnZXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9yZW1vdGVfb2JqZWN0cygpO1xuICAgIHBhcnNlcnMyID0gW1xuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoL15yZW1vdGU6XFxzKiguKykkLywgKHJlc3VsdCwgW3RleHRdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5yZW1vdGVNZXNzYWdlcy5hbGwucHVzaCh0ZXh0LnRyaW0oKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLFxuICAgICAgLi4ucmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIFsvY3JlYXRlIGEgKD86cHVsbHxtZXJnZSkgcmVxdWVzdC9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgKHJlc3VsdCwgW3B1bGxSZXF1ZXN0VXJsXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5yZW1vdGVNZXNzYWdlcy5wdWxsUmVxdWVzdFVybCA9IHB1bGxSZXF1ZXN0VXJsO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIFsvZm91bmQgKFxcZCspIHZ1bG5lcmFiaWxpdGllcy4rXFwoKFteKV0rKVxcKS9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgKHJlc3VsdCwgW2NvdW50LCBzdW1tYXJ5LCB1cmxdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLnZ1bG5lcmFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgIGNvdW50OiBhc051bWJlcihjb3VudCksXG4gICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgdXJsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgUmVtb3RlTWVzc2FnZVN1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbGwgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1bGwudHNcbmZ1bmN0aW9uIHBhcnNlUHVsbEVycm9yUmVzdWx0KHN0ZE91dCwgc3RkRXJyKSB7XG4gIGNvbnN0IHB1bGxFcnJvciA9IHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IFB1bGxGYWlsZWRTdW1tYXJ5KCksIGVycm9yUGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG4gIHJldHVybiBwdWxsRXJyb3IubWVzc2FnZSAmJiBwdWxsRXJyb3I7XG59XG52YXIgRklMRV9VUERBVEVfUkVHRVgsIFNVTU1BUllfUkVHRVgsIEFDVElPTl9SRUdFWCwgcGFyc2VyczMsIGVycm9yUGFyc2VycywgcGFyc2VQdWxsRGV0YWlsLCBwYXJzZVB1bGxSZXN1bHQ7XG52YXIgaW5pdF9wYXJzZV9wdWxsID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1wdWxsLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9QdWxsU3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX3JlbW90ZV9tZXNzYWdlcygpO1xuICAgIEZJTEVfVVBEQVRFX1JFR0VYID0gL15cXHMqKC4rPylcXHMrXFx8XFxzK1xcZCtcXHMqKFxcKyopKC0qKS87XG4gICAgU1VNTUFSWV9SRUdFWCA9IC8oXFxkKylcXEQrKChcXGQrKVxcRCtcXChcXCtcXCkpPyhcXEQrKFxcZCspXFxEK1xcKC1cXCkpPy87XG4gICAgQUNUSU9OX1JFR0VYID0gL14oY3JlYXRlfGRlbGV0ZSkgbW9kZSBcXGQrICguKykvO1xuICAgIHBhcnNlcnMzID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoRklMRV9VUERBVEVfUkVHRVgsIChyZXN1bHQsIFtmaWxlLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICBpZiAoaW5zZXJ0aW9ucykge1xuICAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zW2ZpbGVdID0gaW5zZXJ0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGV0aW9ucykge1xuICAgICAgICAgIHJlc3VsdC5kZWxldGlvbnNbZmlsZV0gPSBkZWxldGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFNVTU1BUllfUkVHRVgsIChyZXN1bHQsIFtjaGFuZ2VzLCAsIGluc2VydGlvbnMsICwgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgICBpZiAoaW5zZXJ0aW9ucyAhPT0gdm9pZCAwIHx8IGRlbGV0aW9ucyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9ICtjaGFuZ2VzIHx8IDA7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuaW5zZXJ0aW9ucyA9ICtpbnNlcnRpb25zIHx8IDA7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuZGVsZXRpb25zID0gK2RlbGV0aW9ucyB8fCAwO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoQUNUSU9OX1JFR0VYLCAocmVzdWx0LCBbYWN0aW9uLCBmaWxlXSkgPT4ge1xuICAgICAgICBhcHBlbmQocmVzdWx0LmZpbGVzLCBmaWxlKTtcbiAgICAgICAgYXBwZW5kKGFjdGlvbiA9PT0gXCJjcmVhdGVcIiA/IHJlc3VsdC5jcmVhdGVkIDogcmVzdWx0LmRlbGV0ZWQsIGZpbGUpO1xuICAgICAgfSlcbiAgICBdO1xuICAgIGVycm9yUGFyc2VycyA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eZnJvbVxccyguKykkL2ksIChyZXN1bHQsIFtyZW1vdGVdKSA9PiB2b2lkIChyZXN1bHQucmVtb3RlID0gcmVtb3RlKSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXmZhdGFsOlxccyguKykkLywgKHJlc3VsdCwgW21lc3NhZ2VdKSA9PiB2b2lkIChyZXN1bHQubWVzc2FnZSA9IG1lc3NhZ2UpKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKVxccysoXFxTKylcXHMrLT5cXHMrKFxcUyspJC8sXG4gICAgICAgIChyZXN1bHQsIFtoYXNoTG9jYWwsIGhhc2hSZW1vdGUsIGJyYW5jaExvY2FsLCBicmFuY2hSZW1vdGVdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmJyYW5jaC5sb2NhbCA9IGJyYW5jaExvY2FsO1xuICAgICAgICAgIHJlc3VsdC5oYXNoLmxvY2FsID0gaGFzaExvY2FsO1xuICAgICAgICAgIHJlc3VsdC5icmFuY2gucmVtb3RlID0gYnJhbmNoUmVtb3RlO1xuICAgICAgICAgIHJlc3VsdC5oYXNoLnJlbW90ZSA9IGhhc2hSZW1vdGU7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICAgIHBhcnNlUHVsbERldGFpbCA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IFB1bGxTdW1tYXJ5KCksIHBhcnNlcnMzLCBbc3RkT3V0LCBzdGRFcnJdKTtcbiAgICB9O1xuICAgIHBhcnNlUHVsbFJlc3VsdCA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBQdWxsU3VtbWFyeSgpLFxuICAgICAgICBwYXJzZVB1bGxEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLFxuICAgICAgICBwYXJzZVJlbW90ZU1lc3NhZ2VzKHN0ZE91dCwgc3RkRXJyKVxuICAgICAgKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLW1lcmdlLnRzXG52YXIgcGFyc2VyczQsIHBhcnNlTWVyZ2VSZXN1bHQsIHBhcnNlTWVyZ2VEZXRhaWw7XG52YXIgaW5pdF9wYXJzZV9tZXJnZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtbWVyZ2UudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X01lcmdlU3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX3B1bGwoKTtcbiAgICBwYXJzZXJzNCA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eQXV0by1tZXJnaW5nXFxzKyguKykkLywgKHN1bW1hcnksIFthdXRvTWVyZ2VdKSA9PiB7XG4gICAgICAgIHN1bW1hcnkubWVyZ2VzLnB1c2goYXV0b01lcmdlKTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15DT05GTElDVFxccytcXCgoLispXFwpOiBNZXJnZSBjb25mbGljdCBpbiAoLispJC8sIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlXSkgPT4ge1xuICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIGZpbGUpKTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eQ09ORkxJQ1RcXHMrXFwoKC4rXFwvZGVsZXRlKVxcKTogKC4rKSBkZWxldGVkIGluICguKykgYW5kLyxcbiAgICAgICAgKHN1bW1hcnksIFtyZWFzb24sIGZpbGUsIGRlbGV0ZVJlZl0pID0+IHtcbiAgICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIGZpbGUsIHsgZGVsZXRlUmVmIH0pKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTovLCAoc3VtbWFyeSwgW3JlYXNvbl0pID0+IHtcbiAgICAgICAgc3VtbWFyeS5jb25mbGljdHMucHVzaChuZXcgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QocmVhc29uLCBudWxsKSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eQXV0b21hdGljIG1lcmdlIGZhaWxlZDtcXHMrKC4rKSQvLCAoc3VtbWFyeSwgW3Jlc3VsdF0pID0+IHtcbiAgICAgICAgc3VtbWFyeS5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICB9KVxuICAgIF07XG4gICAgcGFyc2VNZXJnZVJlc3VsdCA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocGFyc2VNZXJnZURldGFpbChzdGRPdXQsIHN0ZEVyciksIHBhcnNlUHVsbFJlc3VsdChzdGRPdXQsIHN0ZEVycikpO1xuICAgIH07XG4gICAgcGFyc2VNZXJnZURldGFpbCA9IChzdGRPdXQpID0+IHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBNZXJnZVN1bW1hcnlEZXRhaWwoKSwgcGFyc2VyczQsIHN0ZE91dCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvbWVyZ2UudHNcbmZ1bmN0aW9uIG1lcmdlVGFzayhjdXN0b21BcmdzKSB7XG4gIGlmICghY3VzdG9tQXJncy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcIkdpdC5tZXJnZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgb3B0aW9uXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IFtcIm1lcmdlXCIsIC4uLmN1c3RvbUFyZ3NdLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgY29uc3QgbWVyZ2UgPSBwYXJzZU1lcmdlUmVzdWx0KHN0ZE91dCwgc3RkRXJyKTtcbiAgICAgIGlmIChtZXJnZS5mYWlsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdpdFJlc3BvbnNlRXJyb3IobWVyZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X21lcmdlID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvbWVyZ2UudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9yZXNwb25zZV9lcnJvcigpO1xuICAgIGluaXRfcGFyc2VfbWVyZ2UoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1wdXNoLnRzXG5mdW5jdGlvbiBwdXNoUmVzdWx0UHVzaGVkSXRlbShsb2NhbCwgcmVtb3RlLCBzdGF0dXMpIHtcbiAgY29uc3QgZGVsZXRlZCA9IHN0YXR1cy5pbmNsdWRlcyhcImRlbGV0ZWRcIik7XG4gIGNvbnN0IHRhZyA9IHN0YXR1cy5pbmNsdWRlcyhcInRhZ1wiKSB8fCAvXnJlZnNcXC90YWdzLy50ZXN0KGxvY2FsKTtcbiAgY29uc3QgYWxyZWFkeVVwZGF0ZWQgPSAhc3RhdHVzLmluY2x1ZGVzKFwibmV3XCIpO1xuICByZXR1cm4ge1xuICAgIGRlbGV0ZWQsXG4gICAgdGFnLFxuICAgIGJyYW5jaDogIXRhZyxcbiAgICBuZXc6ICFhbHJlYWR5VXBkYXRlZCxcbiAgICBhbHJlYWR5VXBkYXRlZCxcbiAgICBsb2NhbCxcbiAgICByZW1vdGVcbiAgfTtcbn1cbnZhciBwYXJzZXJzNSwgcGFyc2VQdXNoUmVzdWx0LCBwYXJzZVB1c2hEZXRhaWw7XG52YXIgaW5pdF9wYXJzZV9wdXNoID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1wdXNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfcGFyc2VfcmVtb3RlX21lc3NhZ2VzKCk7XG4gICAgcGFyc2VyczUgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXlB1c2hpbmcgdG8gKC4rKSQvLCAocmVzdWx0LCBbcmVwb10pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlcG8gPSByZXBvO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXnVwZGF0aW5nIGxvY2FsIHRyYWNraW5nIHJlZiAnKC4rKScvLCAocmVzdWx0LCBbbG9jYWxdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5yZWYgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQucmVmIHx8IHt9KSwge1xuICAgICAgICAgIGxvY2FsXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXls9Ki1dXFxzKyhbXjpdKyk6KFxcUyspXFxzK1xcWyguKyldJC8sIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCB0eXBlXSkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaGVkLnB1c2gocHVzaFJlc3VsdFB1c2hlZEl0ZW0obG9jYWwsIHJlbW90ZSwgdHlwZSkpO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL15CcmFuY2ggJyhbXiddKyknIHNldCB1cCB0byB0cmFjayByZW1vdGUgYnJhbmNoICcoW14nXSspJyBmcm9tICcoW14nXSspJy8sXG4gICAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCByZW1vdGVOYW1lXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5icmFuY2ggPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQuYnJhbmNoIHx8IHt9KSwge1xuICAgICAgICAgICAgbG9jYWwsXG4gICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICByZW1vdGVOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oW146XSspOihcXFMrKVxccysoW2EtejAtOV0rKVxcLlxcLihbYS16MC05XSspJC8sXG4gICAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCBmcm9tLCB0b10pID0+IHtcbiAgICAgICAgICByZXN1bHQudXBkYXRlID0ge1xuICAgICAgICAgICAgaGVhZDoge1xuICAgICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzaDoge1xuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0b1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICAgIHBhcnNlUHVzaFJlc3VsdCA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgICAgY29uc3QgcHVzaERldGFpbCA9IHBhcnNlUHVzaERldGFpbChzdGRPdXQsIHN0ZEVycik7XG4gICAgICBjb25zdCByZXNwb25zZURldGFpbCA9IHBhcnNlUmVtb3RlTWVzc2FnZXMoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBwdXNoRGV0YWlsKSwgcmVzcG9uc2VEZXRhaWwpO1xuICAgIH07XG4gICAgcGFyc2VQdXNoRGV0YWlsID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHB1c2hlZDogW10gfSwgcGFyc2VyczUsIFtzdGRPdXQsIHN0ZEVycl0pO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3B1c2gudHNcbnZhciBwdXNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHB1c2hfZXhwb3J0cywge1xuICBwdXNoVGFnc1Rhc2s6ICgpID0+IHB1c2hUYWdzVGFzayxcbiAgcHVzaFRhc2s6ICgpID0+IHB1c2hUYXNrXG59KTtcbmZ1bmN0aW9uIHB1c2hUYWdzVGFzayhyZWYgPSB7fSwgY3VzdG9tQXJncykge1xuICBhcHBlbmQoY3VzdG9tQXJncywgXCItLXRhZ3NcIik7XG4gIHJldHVybiBwdXNoVGFzayhyZWYsIGN1c3RvbUFyZ3MpO1xufVxuZnVuY3Rpb24gcHVzaFRhc2socmVmID0ge30sIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJwdXNoXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBpZiAocmVmLmJyYW5jaCkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYuYnJhbmNoKTtcbiAgfVxuICBpZiAocmVmLnJlbW90ZSkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYucmVtb3RlKTtcbiAgfVxuICByZW1vdmUoY29tbWFuZHMsIFwiLXZcIik7XG4gIGFwcGVuZChjb21tYW5kcywgXCItLXZlcmJvc2VcIik7XG4gIGFwcGVuZChjb21tYW5kcywgXCItLXBvcmNlbGFpblwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlUHVzaFJlc3VsdFxuICB9O1xufVxudmFyIGluaXRfcHVzaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3B1c2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3BhcnNlX3B1c2goKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3Nob3cudHNcbmZ1bmN0aW9uIHNob3dfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBzaG93QnVmZmVyKCkge1xuICAgICAgY29uc3QgY29tbWFuZHMgPSBbXCJzaG93XCIsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoXCItLWJpbmFyeVwiKSkge1xuICAgICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgXCItLWJpbmFyeVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBzaG93KCkge1xuICAgICAgY29uc3QgY29tbWFuZHMgPSBbXCJzaG93XCIsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfc2hvdyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3Nob3cudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9GaWxlU3RhdHVzU3VtbWFyeS50c1xudmFyIGZyb21QYXRoUmVnZXgsIEZpbGVTdGF0dXNTdW1tYXJ5O1xudmFyIGluaXRfRmlsZVN0YXR1c1N1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvRmlsZVN0YXR1c1N1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmcm9tUGF0aFJlZ2V4ID0gL14oLispXFwwKC4rKSQvO1xuICAgIEZpbGVTdGF0dXNTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IocGF0aCwgaW5kZXgsIHdvcmtpbmdfZGlyKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy53b3JraW5nX2RpciA9IHdvcmtpbmdfZGlyO1xuICAgICAgICBpZiAoaW5kZXggPT09IFwiUlwiIHx8IHdvcmtpbmdfZGlyID09PSBcIlJcIikge1xuICAgICAgICAgIGNvbnN0IGRldGFpbCA9IGZyb21QYXRoUmVnZXguZXhlYyhwYXRoKSB8fCBbbnVsbCwgcGF0aCwgcGF0aF07XG4gICAgICAgICAgdGhpcy5mcm9tID0gZGV0YWlsWzJdIHx8IFwiXCI7XG4gICAgICAgICAgdGhpcy5wYXRoID0gZGV0YWlsWzFdIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeS50c1xuZnVuY3Rpb24gcmVuYW1lZEZpbGUobGluZSkge1xuICBjb25zdCBbdG8sIGZyb21dID0gbGluZS5zcGxpdChOVUxMKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBmcm9tIHx8IHRvLFxuICAgIHRvXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZXIzKGluZGV4WCwgaW5kZXhZLCBoYW5kbGVyKSB7XG4gIHJldHVybiBbYCR7aW5kZXhYfSR7aW5kZXhZfWAsIGhhbmRsZXJdO1xufVxuZnVuY3Rpb24gY29uZmxpY3RzKGluZGV4WCwgLi4uaW5kZXhZKSB7XG4gIHJldHVybiBpbmRleFkubWFwKCh5KSA9PiBwYXJzZXIzKGluZGV4WCwgeSwgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jb25mbGljdGVkLCBmaWxlKSkpO1xufVxuZnVuY3Rpb24gc3BsaXRMaW5lKHJlc3VsdCwgbGluZVN0cikge1xuICBjb25zdCB0cmltbWVkMiA9IGxpbmVTdHIudHJpbSgpO1xuICBzd2l0Y2ggKFwiIFwiKSB7XG4gICAgY2FzZSB0cmltbWVkMi5jaGFyQXQoMik6XG4gICAgICByZXR1cm4gZGF0YSh0cmltbWVkMi5jaGFyQXQoMCksIHRyaW1tZWQyLmNoYXJBdCgxKSwgdHJpbW1lZDIuc3Vic3RyKDMpKTtcbiAgICBjYXNlIHRyaW1tZWQyLmNoYXJBdCgxKTpcbiAgICAgIHJldHVybiBkYXRhKFwiIFwiIC8qIE5PTkUgKi8sIHRyaW1tZWQyLmNoYXJBdCgwKSwgdHJpbW1lZDIuc3Vic3RyKDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIGRhdGEoaW5kZXgsIHdvcmtpbmdEaXIsIHBhdGgpIHtcbiAgICBjb25zdCByYXcgPSBgJHtpbmRleH0ke3dvcmtpbmdEaXJ9YDtcbiAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyczYuZ2V0KHJhdyk7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIocmVzdWx0LCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHJhdyAhPT0gXCIjI1wiICYmIHJhdyAhPT0gXCIhIVwiKSB7XG4gICAgICByZXN1bHQuZmlsZXMucHVzaChuZXcgRmlsZVN0YXR1c1N1bW1hcnkocGF0aCwgaW5kZXgsIHdvcmtpbmdEaXIpKTtcbiAgICB9XG4gIH1cbn1cbnZhciBTdGF0dXNTdW1tYXJ5LCBwYXJzZXJzNiwgcGFyc2VTdGF0dXNTdW1tYXJ5O1xudmFyIGluaXRfU3RhdHVzU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9TdGF0dXNTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfRmlsZVN0YXR1c1N1bW1hcnkoKTtcbiAgICBTdGF0dXNTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubm90X2FkZGVkID0gW107XG4gICAgICAgIHRoaXMuY29uZmxpY3RlZCA9IFtdO1xuICAgICAgICB0aGlzLmNyZWF0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxldGVkID0gW107XG4gICAgICAgIHRoaXMuaWdub3JlZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IFtdO1xuICAgICAgICB0aGlzLnJlbmFtZWQgPSBbXTtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YWdlZCA9IFtdO1xuICAgICAgICB0aGlzLmFoZWFkID0gMDtcbiAgICAgICAgdGhpcy5iZWhpbmQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRyYWNraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2xlYW4gPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLmZpbGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlcnM2ID0gbmV3IE1hcChbXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICBcIkFcIiAvKiBBRERFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiIFwiIC8qIE5PTkUgKi8sXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQuZGVsZXRlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICBcIk1cIiAvKiBNT0RJRklFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIkFcIiAvKiBBRERFRCAqLyxcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIkFcIiAvKiBBRERFRCAqLyxcbiAgICAgICAgXCJNXCIgLyogTU9ESUZJRUQgKi8sXG4gICAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQuY3JlYXRlZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICAgICApLFxuICAgICAgcGFyc2VyMyhcbiAgICAgICAgXCJEXCIgLyogREVMRVRFRCAqLyxcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5kZWxldGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIk1cIiAvKiBNT0RJRklFRCAqLyxcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICAgICApLFxuICAgICAgcGFyc2VyMyhcbiAgICAgICAgXCJNXCIgLyogTU9ESUZJRUQgKi8sXG4gICAgICAgIFwiTVwiIC8qIE1PRElGSUVEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFwiUlwiIC8qIFJFTkFNRUQgKi8sIFwiIFwiIC8qIE5PTkUgKi8sIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgICAgYXBwZW5kKHJlc3VsdC5yZW5hbWVkLCByZW5hbWVkRmlsZShmaWxlKSk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXCJSXCIgLyogUkVOQU1FRCAqLywgXCJNXCIgLyogTU9ESUZJRUQgKi8sIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVuYW1lZCA9IHJlbmFtZWRGaWxlKGZpbGUpO1xuICAgICAgICBhcHBlbmQocmVzdWx0LnJlbmFtZWQsIHJlbmFtZWQpO1xuICAgICAgICBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCByZW5hbWVkLnRvKTtcbiAgICAgIH0pLFxuICAgICAgcGFyc2VyMyhcIiFcIiAvKiBJR05PUkVEICovLCBcIiFcIiAvKiBJR05PUkVEICovLCAoX3Jlc3VsdCwgX2ZpbGUpID0+IHtcbiAgICAgICAgYXBwZW5kKF9yZXN1bHQuaWdub3JlZCA9IF9yZXN1bHQuaWdub3JlZCB8fCBbXSwgX2ZpbGUpO1xuICAgICAgfSksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIj9cIiAvKiBVTlRSQUNLRUQgKi8sXG4gICAgICAgIFwiP1wiIC8qIFVOVFJBQ0tFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5ub3RfYWRkZWQsIGZpbGUpXG4gICAgICApLFxuICAgICAgLi4uY29uZmxpY3RzKFwiQVwiIC8qIEFEREVEICovLCBcIkFcIiAvKiBBRERFRCAqLywgXCJVXCIgLyogVU5NRVJHRUQgKi8pLFxuICAgICAgLi4uY29uZmxpY3RzKFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIlVcIiAvKiBVTk1FUkdFRCAqL1xuICAgICAgKSxcbiAgICAgIC4uLmNvbmZsaWN0cyhcbiAgICAgICAgXCJVXCIgLyogVU5NRVJHRUQgKi8sXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIlVcIiAvKiBVTk1FUkdFRCAqL1xuICAgICAgKSxcbiAgICAgIFtcbiAgICAgICAgXCIjI1wiLFxuICAgICAgICAocmVzdWx0LCBsaW5lKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWhlYWRSZWcgPSAvYWhlYWQgKFxcZCspLztcbiAgICAgICAgICBjb25zdCBiZWhpbmRSZWcgPSAvYmVoaW5kIChcXGQrKS87XG4gICAgICAgICAgY29uc3QgY3VycmVudFJlZyA9IC9eKC4rPyg/PSg/OlxcLnszfXxcXHN8JCkpKS87XG4gICAgICAgICAgY29uc3QgdHJhY2tpbmdSZWcgPSAvXFwuezN9KFxcUyopLztcbiAgICAgICAgICBjb25zdCBvbkVtcHR5QnJhbmNoUmVnID0gL1xcc29uXFxzKFtcXFNdKykkLztcbiAgICAgICAgICBsZXQgcmVnZXhSZXN1bHQ7XG4gICAgICAgICAgcmVnZXhSZXN1bHQgPSBhaGVhZFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC5haGVhZCA9IHJlZ2V4UmVzdWx0ICYmICtyZWdleFJlc3VsdFsxXSB8fCAwO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gYmVoaW5kUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LmJlaGluZCA9IHJlZ2V4UmVzdWx0ICYmICtyZWdleFJlc3VsdFsxXSB8fCAwO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gY3VycmVudFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC5jdXJyZW50ID0gcmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV07XG4gICAgICAgICAgcmVnZXhSZXN1bHQgPSB0cmFja2luZ1JlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC50cmFja2luZyA9IHJlZ2V4UmVzdWx0ICYmIHJlZ2V4UmVzdWx0WzFdO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gb25FbXB0eUJyYW5jaFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC5jdXJyZW50ID0gcmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV0gfHwgcmVzdWx0LmN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0LmRldGFjaGVkID0gL1xcKG5vIGJyYW5jaFxcKS8udGVzdChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIF0pO1xuICAgIHBhcnNlU3RhdHVzU3VtbWFyeSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChOVUxMKTtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBTdGF0dXNTdW1tYXJ5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7ICkge1xuICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2krK10udHJpbSgpO1xuICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5jaGFyQXQoMCkgPT09IFwiUlwiIC8qIFJFTkFNRUQgKi8pIHtcbiAgICAgICAgICBsaW5lICs9IE5VTEwgKyAobGluZXNbaSsrXSB8fCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdExpbmUoc3RhdHVzLCBsaW5lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3Mvc3RhdHVzLnRzXG5mdW5jdGlvbiBzdGF0dXNUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgXCJzdGF0dXNcIixcbiAgICBcIi0tcG9yY2VsYWluXCIsXG4gICAgXCItYlwiLFxuICAgIFwiLXVcIixcbiAgICBcIi0tbnVsbFwiLFxuICAgIC4uLmN1c3RvbUFyZ3MuZmlsdGVyKChhcmcpID0+ICFpZ25vcmVkT3B0aW9ucy5pbmNsdWRlcyhhcmcpKVxuICBdO1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gcGFyc2VTdGF0dXNTdW1tYXJ5KHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpZ25vcmVkT3B0aW9ucztcbnZhciBpbml0X3N0YXR1cyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3N0YXR1cy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfU3RhdHVzU3VtbWFyeSgpO1xuICAgIGlnbm9yZWRPcHRpb25zID0gW1wiLS1udWxsXCIsIFwiLXpcIl07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3ZlcnNpb24udHNcbmZ1bmN0aW9uIHZlcnNpb25SZXNwb25zZShtYWpvciA9IDAsIG1pbm9yID0gMCwgcGF0Y2ggPSAwLCBhZ2VudCA9IFwiXCIsIGluc3RhbGxlZCA9IHRydWUpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBtYWpvcixcbiAgICAgIG1pbm9yLFxuICAgICAgcGF0Y2gsXG4gICAgICBhZ2VudCxcbiAgICAgIGluc3RhbGxlZFxuICAgIH0sXG4gICAgXCJ0b1N0cmluZ1wiLFxuICAgIHtcbiAgICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YDtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBub3RJbnN0YWxsZWRSZXNwb25zZSgpIHtcbiAgcmV0dXJuIHZlcnNpb25SZXNwb25zZSgwLCAwLCAwLCBcIlwiLCBmYWxzZSk7XG59XG5mdW5jdGlvbiB2ZXJzaW9uX2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHtcbiAgICAgICAgY29tbWFuZHM6IFtcIi0tdmVyc2lvblwiXSxcbiAgICAgICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgICAgIHBhcnNlcjogdmVyc2lvblBhcnNlcixcbiAgICAgICAgb25FcnJvcihyZXN1bHQsIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5leGl0Q29kZSA9PT0gLTIgLyogTk9UX0ZPVU5EICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShCdWZmZXIuZnJvbShOT1RfSU5TVEFMTEVEKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZhaWwoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB2ZXJzaW9uUGFyc2VyKHN0ZE91dCkge1xuICBpZiAoc3RkT3V0ID09PSBOT1RfSU5TVEFMTEVEKSB7XG4gICAgcmV0dXJuIG5vdEluc3RhbGxlZFJlc3BvbnNlKCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UodmVyc2lvblJlc3BvbnNlKDAsIDAsIDAsIHN0ZE91dCksIHBhcnNlcnM3LCBzdGRPdXQpO1xufVxudmFyIE5PVF9JTlNUQUxMRUQsIHBhcnNlcnM3O1xudmFyIGluaXRfdmVyc2lvbiA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3ZlcnNpb24udHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgTk9UX0lOU1RBTExFRCA9IFwiaW5zdGFsbGVkPWZhbHNlXCI7XG4gICAgcGFyc2VyczcgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL3ZlcnNpb24gKFxcZCspXFwuKFxcZCspXFwuKFxcZCspKD86XFxzKlxcKCguKylcXCkpPy8sXG4gICAgICAgIChyZXN1bHQsIFttYWpvciwgbWlub3IsIHBhdGNoLCBhZ2VudCA9IFwiXCJdKSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIHZlcnNpb25SZXNwb25zZShhc051bWJlcihtYWpvciksIGFzTnVtYmVyKG1pbm9yKSwgYXNOdW1iZXIocGF0Y2gpLCBhZ2VudClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXEQrKSguKyk/JC8sXG4gICAgICAgIChyZXN1bHQsIFttYWpvciwgbWlub3IsIHBhdGNoLCBhZ2VudCA9IFwiXCJdKSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZlcnNpb25SZXNwb25zZShhc051bWJlcihtYWpvciksIGFzTnVtYmVyKG1pbm9yKSwgcGF0Y2gsIGFnZW50KSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9zaW1wbGUtZ2l0LWFwaS50c1xudmFyIHNpbXBsZV9naXRfYXBpX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNpbXBsZV9naXRfYXBpX2V4cG9ydHMsIHtcbiAgU2ltcGxlR2l0QXBpOiAoKSA9PiBTaW1wbGVHaXRBcGlcbn0pO1xudmFyIFNpbXBsZUdpdEFwaTtcbnZhciBpbml0X3NpbXBsZV9naXRfYXBpID0gX19lc20oe1xuICBcInNyYy9saWIvc2ltcGxlLWdpdC1hcGkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2tfY2FsbGJhY2soKTtcbiAgICBpbml0X2NoYW5nZV93b3JraW5nX2RpcmVjdG9yeSgpO1xuICAgIGluaXRfY2hlY2tvdXQoKTtcbiAgICBpbml0X2NvdW50X29iamVjdHMoKTtcbiAgICBpbml0X2NvbW1pdCgpO1xuICAgIGluaXRfY29uZmlnKCk7XG4gICAgaW5pdF9maXJzdF9jb21taXQoKTtcbiAgICBpbml0X2dyZXAoKTtcbiAgICBpbml0X2hhc2hfb2JqZWN0KCk7XG4gICAgaW5pdF9pbml0KCk7XG4gICAgaW5pdF9sb2coKTtcbiAgICBpbml0X21lcmdlKCk7XG4gICAgaW5pdF9wdXNoKCk7XG4gICAgaW5pdF9zaG93KCk7XG4gICAgaW5pdF9zdGF0dXMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBpbml0X3ZlcnNpb24oKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgU2ltcGxlR2l0QXBpID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoX2V4ZWN1dG9yKSB7XG4gICAgICAgIHRoaXMuX2V4ZWN1dG9yID0gX2V4ZWN1dG9yO1xuICAgICAgfVxuICAgICAgX3J1blRhc2sodGFzaywgdGhlbikge1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuX2V4ZWN1dG9yLmNoYWluKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBjaGFpbi5wdXNoKHRhc2spO1xuICAgICAgICBpZiAodGhlbikge1xuICAgICAgICAgIHRhc2tDYWxsYmFjayh0YXNrLCBwcm9taXNlLCB0aGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzLCB7XG4gICAgICAgICAgdGhlbjogeyB2YWx1ZTogcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSkgfSxcbiAgICAgICAgICBjYXRjaDogeyB2YWx1ZTogcHJvbWlzZS5jYXRjaC5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICAgX2V4ZWN1dG9yOiB7IHZhbHVlOiBjaGFpbiB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYWRkKGZpbGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wiYWRkXCIsIC4uLmFzQXJyYXkoZmlsZXMpXSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGN3ZChkaXJlY3RvcnkpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodHlwZW9mIGRpcmVjdG9yeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeSwgdGhpcy5fZXhlY3V0b3IpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChkaXJlY3RvcnkgPT0gbnVsbCA/IHZvaWQgMCA6IGRpcmVjdG9yeS5wYXRoKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2soXG4gICAgICAgICAgICAgIGRpcmVjdG9yeS5wYXRoLFxuICAgICAgICAgICAgICBkaXJlY3Rvcnkucm9vdCAmJiB0aGlzLl9leGVjdXRvciB8fCB2b2lkIDBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFwiR2l0LmN3ZDogd29ya2luZ0RpcmVjdG9yeSBtdXN0IGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nXCIpLFxuICAgICAgICAgIG5leHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhhc2hPYmplY3QocGF0aCwgd3JpdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgaGFzaE9iamVjdFRhc2socGF0aCwgd3JpdGUgPT09IHRydWUpLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbml0KGJhcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgaW5pdFRhc2soYmFyZSA9PT0gdHJ1ZSwgdGhpcy5fZXhlY3V0b3IuY3dkLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1lcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBtZXJnZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtZXJnZUZyb21UbyhyZW1vdGUsIGJyYW5jaCkge1xuICAgICAgICBpZiAoIShmaWx0ZXJTdHJpbmcocmVtb3RlKSAmJiBmaWx0ZXJTdHJpbmcoYnJhbmNoKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICAgIGBHaXQubWVyZ2VGcm9tVG8gcmVxdWlyZXMgdGhhdCB0aGUgJ3JlbW90ZScgYW5kICdicmFuY2gnIGFyZ3VtZW50cyBhcmUgc3VwcGxpZWQgYXMgc3RyaW5nc2BcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIG1lcmdlVGFzayhbcmVtb3RlLCBicmFuY2gsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cywgZmFsc2UpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvdXRwdXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3Iub3V0cHV0SGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcHVzaCgpIHtcbiAgICAgICAgY29uc3QgdGFzayA9IHB1c2hUYXNrKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlbW90ZTogZmlsdGVyVHlwZShhcmd1bWVudHNbMF0sIGZpbHRlclN0cmluZyksXG4gICAgICAgICAgICBicmFuY2g6IGZpbHRlclR5cGUoYXJndW1lbnRzWzFdLCBmaWx0ZXJTdHJpbmcpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBzdGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJzdGFzaFwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIHN0YXR1c1Rhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgU2ltcGxlR2l0QXBpLnByb3RvdHlwZSxcbiAgICAgIGNoZWNrb3V0X2RlZmF1bHQoKSxcbiAgICAgIGNvbW1pdF9kZWZhdWx0KCksXG4gICAgICBjb25maWdfZGVmYXVsdCgpLFxuICAgICAgY291bnRfb2JqZWN0c19kZWZhdWx0KCksXG4gICAgICBmaXJzdF9jb21taXRfZGVmYXVsdCgpLFxuICAgICAgZ3JlcF9kZWZhdWx0KCksXG4gICAgICBsb2dfZGVmYXVsdCgpLFxuICAgICAgc2hvd19kZWZhdWx0KCksXG4gICAgICB2ZXJzaW9uX2RlZmF1bHQoKVxuICAgICk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3J1bm5lcnMvc2NoZWR1bGVyLnRzXG52YXIgc2NoZWR1bGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNjaGVkdWxlcl9leHBvcnRzLCB7XG4gIFNjaGVkdWxlcjogKCkgPT4gU2NoZWR1bGVyXG59KTtcbmltcG9ydCB7IGNyZWF0ZURlZmVycmVkIH0gZnJvbSBcIkBrd3NpdGVzL3Byb21pc2UtZGVmZXJyZWRcIjtcbnZhciBjcmVhdGVTY2hlZHVsZWRUYXNrLCBTY2hlZHVsZXI7XG52YXIgaW5pdF9zY2hlZHVsZXIgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9ydW5uZXJzL3NjaGVkdWxlci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X2dpdF9sb2dnZXIoKTtcbiAgICBjcmVhdGVTY2hlZHVsZWRUYXNrID0gKCgpID0+IHtcbiAgICAgIGxldCBpZCA9IDA7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZCsrO1xuICAgICAgICBjb25zdCB7IHByb21pc2UsIGRvbmUgfSA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICBkb25lLFxuICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgU2NoZWR1bGVyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoY29uY3VycmVuY3kgPSAyKSB7XG4gICAgICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJcIiwgXCJzY2hlZHVsZXJcIik7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5sb2dnZXIoYENvbnN0cnVjdGVkLCBjb25jdXJyZW5jeT0lc2AsIGNvbmN1cnJlbmN5KTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlKCkge1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZy5sZW5ndGggfHwgdGhpcy5ydW5uaW5nLmxlbmd0aCA+PSB0aGlzLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICBgU2NoZWR1bGUgYXR0ZW1wdCBpZ25vcmVkLCBwZW5kaW5nPSVzIHJ1bm5pbmc9JXMgY29uY3VycmVuY3k9JXNgLFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFzayA9IGFwcGVuZCh0aGlzLnJ1bm5pbmcsIHRoaXMucGVuZGluZy5zaGlmdCgpKTtcbiAgICAgICAgdGhpcy5sb2dnZXIoYEF0dGVtcHRpbmcgaWQ9JXNgLCB0YXNrLmlkKTtcbiAgICAgICAgdGFzay5kb25lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ2dlcihgQ29tcGxldGluZyBpZD1gLCB0YXNrLmlkKTtcbiAgICAgICAgICByZW1vdmUodGhpcy5ydW5uaW5nLCB0YXNrKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCBpZCB9ID0gYXBwZW5kKHRoaXMucGVuZGluZywgY3JlYXRlU2NoZWR1bGVkVGFzaygpKTtcbiAgICAgICAgdGhpcy5sb2dnZXIoYFNjaGVkdWxpbmcgaWQ9JXNgLCBpZCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHNcbnZhciBhcHBseV9wYXRjaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChhcHBseV9wYXRjaF9leHBvcnRzLCB7XG4gIGFwcGx5UGF0Y2hUYXNrOiAoKSA9PiBhcHBseVBhdGNoVGFza1xufSk7XG5mdW5jdGlvbiBhcHBseVBhdGNoVGFzayhwYXRjaGVzLCBjdXN0b21BcmdzKSB7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcImFwcGx5XCIsIC4uLmN1c3RvbUFyZ3MsIC4uLnBhdGNoZXNdKTtcbn1cbnZhciBpbml0X2FwcGx5X3BhdGNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnkudHNcbmZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuY2gsXG4gICAgaGFzaCxcbiAgICBzdWNjZXNzOiB0cnVlXG4gIH07XG59XG5mdW5jdGlvbiBicmFuY2hEZWxldGlvbkZhaWx1cmUoYnJhbmNoKSB7XG4gIHJldHVybiB7XG4gICAgYnJhbmNoLFxuICAgIGhhc2g6IG51bGwsXG4gICAgc3VjY2VzczogZmFsc2VcbiAgfTtcbn1cbnZhciBCcmFuY2hEZWxldGlvbkJhdGNoO1xudmFyIGluaXRfQnJhbmNoRGVsZXRlU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hEZWxldGVTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgQnJhbmNoRGVsZXRpb25CYXRjaCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFsbCA9IFtdO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gtZGVsZXRlLnRzXG5mdW5jdGlvbiBoYXNCcmFuY2hEZWxldGlvbkVycm9yKGRhdGEsIHByb2Nlc3NFeGl0Q29kZSkge1xuICByZXR1cm4gcHJvY2Vzc0V4aXRDb2RlID09PSAxIC8qIEVSUk9SICovICYmIGRlbGV0ZUVycm9yUmVnZXgudGVzdChkYXRhKTtcbn1cbnZhciBkZWxldGVTdWNjZXNzUmVnZXgsIGRlbGV0ZUVycm9yUmVnZXgsIHBhcnNlcnM4LCBwYXJzZUJyYW5jaERlbGV0aW9ucztcbnZhciBpbml0X3BhcnNlX2JyYW5jaF9kZWxldGUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0JyYW5jaERlbGV0ZVN1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgZGVsZXRlU3VjY2Vzc1JlZ2V4ID0gLyhcXFMrKVxccytcXChcXFMrXFxzKFteKV0rKVxcKS87XG4gICAgZGVsZXRlRXJyb3JSZWdleCA9IC9eZXJyb3JbXiddKycoW14nXSspJy9tO1xuICAgIHBhcnNlcnM4ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoZGVsZXRlU3VjY2Vzc1JlZ2V4LCAocmVzdWx0LCBbYnJhbmNoLCBoYXNoXSkgPT4ge1xuICAgICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpO1xuICAgICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgICByZXN1bHQuYnJhbmNoZXNbYnJhbmNoXSA9IGRlbGV0aW9uO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihkZWxldGVFcnJvclJlZ2V4LCAocmVzdWx0LCBbYnJhbmNoXSkgPT4ge1xuICAgICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2gpO1xuICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goZGVsZXRpb24pO1xuICAgICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgICByZXN1bHQuYnJhbmNoZXNbYnJhbmNoXSA9IGRlbGV0aW9uO1xuICAgICAgfSlcbiAgICBdO1xuICAgIHBhcnNlQnJhbmNoRGVsZXRpb25zID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgQnJhbmNoRGVsZXRpb25CYXRjaCgpLCBwYXJzZXJzOCwgW3N0ZE91dCwgc3RkRXJyXSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnkudHNcbnZhciBCcmFuY2hTdW1tYXJ5UmVzdWx0O1xudmFyIGluaXRfQnJhbmNoU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgQnJhbmNoU3VtbWFyeVJlc3VsdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFsbCA9IFtdO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudCA9IFwiXCI7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHB1c2goc3RhdHVzLCBkZXRhY2hlZCwgbmFtZSwgY29tbWl0LCBsYWJlbCkge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcIipcIiAvKiBDVVJSRU5UICovKSB7XG4gICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGwucHVzaChuYW1lKTtcbiAgICAgICAgdGhpcy5icmFuY2hlc1tuYW1lXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiBzdGF0dXMgPT09IFwiKlwiIC8qIENVUlJFTlQgKi8sXG4gICAgICAgICAgbGlua2VkV29ya1RyZWU6IHN0YXR1cyA9PT0gXCIrXCIgLyogTElOS0VEICovLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY29tbWl0LFxuICAgICAgICAgIGxhYmVsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gudHNcbmZ1bmN0aW9uIGJyYW5jaFN0YXR1cyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQgPyBpbnB1dC5jaGFyQXQoMCkgOiBcIlwiO1xufVxuZnVuY3Rpb24gcGFyc2VCcmFuY2hTdW1tYXJ5KHN0ZE91dCkge1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgQnJhbmNoU3VtbWFyeVJlc3VsdCgpLCBwYXJzZXJzOSwgc3RkT3V0KTtcbn1cbnZhciBwYXJzZXJzOTtcbnZhciBpbml0X3BhcnNlX2JyYW5jaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9CcmFuY2hTdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnM5ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKFsqK11cXHMpP1xcKCg/OkhFQUQgKT9kZXRhY2hlZCAoPzpmcm9tfGF0KSAoXFxTKylcXClcXHMrKFthLXowLTldKylcXHMoLiopJC8sXG4gICAgICAgIChyZXN1bHQsIFtjdXJyZW50LCBuYW1lLCBjb21taXQsIGxhYmVsXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgdHJ1ZSwgbmFtZSwgY29tbWl0LCBsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgbmV3IFJlZ0V4cChcIl4oWyorXVxcXFxzKT8oXFxcXFMrKVxcXFxzKyhbYS16MC05XSspXFxcXHM/KC4qKSRcIiwgXCJzXCIpLFxuICAgICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIGZhbHNlLCBuYW1lLCBjb21taXQsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2JyYW5jaC50c1xudmFyIGJyYW5jaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChicmFuY2hfZXhwb3J0cywge1xuICBicmFuY2hMb2NhbFRhc2s6ICgpID0+IGJyYW5jaExvY2FsVGFzayxcbiAgYnJhbmNoVGFzazogKCkgPT4gYnJhbmNoVGFzayxcbiAgY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kOiAoKSA9PiBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQsXG4gIGRlbGV0ZUJyYW5jaFRhc2s6ICgpID0+IGRlbGV0ZUJyYW5jaFRhc2ssXG4gIGRlbGV0ZUJyYW5jaGVzVGFzazogKCkgPT4gZGVsZXRlQnJhbmNoZXNUYXNrXG59KTtcbmZ1bmN0aW9uIGNvbnRhaW5zRGVsZXRlQnJhbmNoQ29tbWFuZChjb21tYW5kcykge1xuICBjb25zdCBkZWxldGVDb21tYW5kcyA9IFtcIi1kXCIsIFwiLURcIiwgXCItLWRlbGV0ZVwiXTtcbiAgcmV0dXJuIGNvbW1hbmRzLnNvbWUoKGNvbW1hbmQpID0+IGRlbGV0ZUNvbW1hbmRzLmluY2x1ZGVzKGNvbW1hbmQpKTtcbn1cbmZ1bmN0aW9uIGJyYW5jaFRhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBpc0RlbGV0ZSA9IGNvbnRhaW5zRGVsZXRlQnJhbmNoQ29tbWFuZChjdXN0b21BcmdzKTtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJicmFuY2hcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChjb21tYW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb21tYW5kcy5wdXNoKFwiLWFcIik7XG4gIH1cbiAgaWYgKCFjb21tYW5kcy5pbmNsdWRlcyhcIi12XCIpKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIFwiLXZcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kcyxcbiAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIGlmIChpc0RlbGV0ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpLmFsbFswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBicmFuY2hMb2NhbFRhc2soKSB7XG4gIGNvbnN0IHBhcnNlcjQgPSBwYXJzZUJyYW5jaFN1bW1hcnk7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcImJyYW5jaFwiLCBcIi12XCJdLFxuICAgIHBhcnNlcjogcGFyc2VyNFxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlQnJhbmNoZXNUYXNrKGJyYW5jaGVzLCBmb3JjZURlbGV0ZSA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcImJyYW5jaFwiLCBcIi12XCIsIGZvcmNlRGVsZXRlID8gXCItRFwiIDogXCItZFwiLCAuLi5icmFuY2hlc10sXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpO1xuICAgIH0sXG4gICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRPdXQgfSwgZXJyb3IsIGRvbmUsIGZhaWwpIHtcbiAgICAgIGlmICghaGFzQnJhbmNoRGVsZXRpb25FcnJvcihTdHJpbmcoZXJyb3IpLCBleGl0Q29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgfVxuICAgICAgZG9uZShzdGRPdXQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJyYW5jaFRhc2soYnJhbmNoLCBmb3JjZURlbGV0ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHRhc2sgPSB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcImJyYW5jaFwiLCBcIi12XCIsIGZvcmNlRGVsZXRlID8gXCItRFwiIDogXCItZFwiLCBicmFuY2hdLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoRGVsZXRpb25zKHN0ZE91dCwgc3RkRXJyKS5icmFuY2hlc1ticmFuY2hdO1xuICAgIH0sXG4gICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRFcnIsIHN0ZE91dCB9LCBlcnJvciwgXywgZmFpbCkge1xuICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihcbiAgICAgICAgdGFzay5wYXJzZXIoYnVmZmVyVG9TdHJpbmcoc3RkT3V0KSwgYnVmZmVyVG9TdHJpbmcoc3RkRXJyKSksXG4gICAgICAgIFN0cmluZyhlcnJvcilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGFzaztcbn1cbnZhciBpbml0X2JyYW5jaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2JyYW5jaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF9wYXJzZV9icmFuY2hfZGVsZXRlKCk7XG4gICAgaW5pdF9wYXJzZV9icmFuY2goKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9DaGVja0lnbm9yZS50c1xudmFyIHBhcnNlQ2hlY2tJZ25vcmU7XG52YXIgaW5pdF9DaGVja0lnbm9yZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9DaGVja0lnbm9yZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHBhcnNlQ2hlY2tJZ25vcmUgPSAodGV4dCkgPT4ge1xuICAgICAgcmV0dXJuIHRleHQuc3BsaXQoL1xcbi9nKS5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKS5maWx0ZXIoKGZpbGUpID0+ICEhZmlsZSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hlY2staWdub3JlLnRzXG52YXIgY2hlY2tfaWdub3JlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNoZWNrX2lnbm9yZV9leHBvcnRzLCB7XG4gIGNoZWNrSWdub3JlVGFzazogKCkgPT4gY2hlY2tJZ25vcmVUYXNrXG59KTtcbmZ1bmN0aW9uIGNoZWNrSWdub3JlVGFzayhwYXRocykge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBbXCJjaGVjay1pZ25vcmVcIiwgLi4ucGF0aHNdLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VDaGVja0lnbm9yZVxuICB9O1xufVxudmFyIGluaXRfY2hlY2tfaWdub3JlID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY2hlY2staWdub3JlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9DaGVja0lnbm9yZSgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jbG9uZS50c1xudmFyIGNsb25lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNsb25lX2V4cG9ydHMsIHtcbiAgY2xvbmVNaXJyb3JUYXNrOiAoKSA9PiBjbG9uZU1pcnJvclRhc2ssXG4gIGNsb25lVGFzazogKCkgPT4gY2xvbmVUYXNrXG59KTtcbmZ1bmN0aW9uIGRpc2FsbG93ZWRDb21tYW5kKGNvbW1hbmQpIHtcbiAgcmV0dXJuIC9eLS11cGxvYWQtcGFjayg9fCQpLy50ZXN0KGNvbW1hbmQpO1xufVxuZnVuY3Rpb24gY2xvbmVUYXNrKHJlcG8sIGRpcmVjdG9yeSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNsb25lXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBmaWx0ZXJTdHJpbmcocmVwbykgJiYgY29tbWFuZHMucHVzaChyZXBvKTtcbiAgZmlsdGVyU3RyaW5nKGRpcmVjdG9yeSkgJiYgY29tbWFuZHMucHVzaChkaXJlY3RvcnkpO1xuICBjb25zdCBiYW5uZWQgPSBjb21tYW5kcy5maW5kKGRpc2FsbG93ZWRDb21tYW5kKTtcbiAgaWYgKGJhbm5lZCkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZmV0Y2g6IHBvdGVudGlhbCBleHBsb2l0IGFyZ3VtZW50IGJsb2NrZWQuYCk7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gY2xvbmVNaXJyb3JUYXNrKHJlcG8sIGRpcmVjdG9yeSwgY3VzdG9tQXJncykge1xuICBhcHBlbmQoY3VzdG9tQXJncywgXCItLW1pcnJvclwiKTtcbiAgcmV0dXJuIGNsb25lVGFzayhyZXBvLCBkaXJlY3RvcnksIGN1c3RvbUFyZ3MpO1xufVxudmFyIGluaXRfY2xvbmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jbG9uZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1mZXRjaC50c1xuZnVuY3Rpb24gcGFyc2VGZXRjaFJlc3VsdChzdGRPdXQsIHN0ZEVycikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcmF3OiBzdGRPdXQsXG4gICAgcmVtb3RlOiBudWxsLFxuICAgIGJyYW5jaGVzOiBbXSxcbiAgICB0YWdzOiBbXSxcbiAgICB1cGRhdGVkOiBbXSxcbiAgICBkZWxldGVkOiBbXVxuICB9O1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMxMCwgW3N0ZE91dCwgc3RkRXJyXSk7XG59XG52YXIgcGFyc2VyczEwO1xudmFyIGluaXRfcGFyc2VfZmV0Y2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWZldGNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnMxMCA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9Gcm9tICguKykkLywgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlbW90ZSA9IHJlbW90ZTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL1xcKiBcXFtuZXcgYnJhbmNoXVxccysoXFxTKylcXHMqLT4gKC4rKSQvLCAocmVzdWx0LCBbbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgIHJlc3VsdC5icmFuY2hlcy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRyYWNraW5nXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXFwqIFxcW25ldyB0YWddXFxzKyhcXFMrKVxccyotPiAoLispJC8sIChyZXN1bHQsIFtuYW1lLCB0cmFja2luZ10pID0+IHtcbiAgICAgICAgcmVzdWx0LnRhZ3MucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0cmFja2luZ1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoLy0gXFxbZGVsZXRlZF1cXHMrXFxTK1xccyotPiAoLispJC8sIChyZXN1bHQsIFt0cmFja2luZ10pID0+IHtcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWQucHVzaCh7XG4gICAgICAgICAgdHJhY2tpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXFxzKihbXi5dKylcXC5cXC4oXFxTKylcXHMrKFxcUyspXFxzKi0+ICguKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2Zyb20sIHRvLCBuYW1lLCB0cmFja2luZ10pID0+IHtcbiAgICAgICAgICByZXN1bHQudXBkYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0cmFja2luZyxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgZnJvbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvZmV0Y2gudHNcbnZhciBmZXRjaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChmZXRjaF9leHBvcnRzLCB7XG4gIGZldGNoVGFzazogKCkgPT4gZmV0Y2hUYXNrXG59KTtcbmZ1bmN0aW9uIGRpc2FsbG93ZWRDb21tYW5kMihjb21tYW5kKSB7XG4gIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cbmZ1bmN0aW9uIGZldGNoVGFzayhyZW1vdGUsIGJyYW5jaCwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImZldGNoXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgIGNvbW1hbmRzLnB1c2gocmVtb3RlLCBicmFuY2gpO1xuICB9XG4gIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQyKTtcbiAgaWYgKGJhbm5lZCkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZmV0Y2g6IHBvdGVudGlhbCBleHBsb2l0IGFyZ3VtZW50IGJsb2NrZWQuYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlRmV0Y2hSZXN1bHRcbiAgfTtcbn1cbnZhciBpbml0X2ZldGNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZmV0Y2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3BhcnNlX2ZldGNoKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50c1xuZnVuY3Rpb24gcGFyc2VNb3ZlUmVzdWx0KHN0ZE91dCkge1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IG1vdmVzOiBbXSB9LCBwYXJzZXJzMTEsIHN0ZE91dCk7XG59XG52YXIgcGFyc2VyczExO1xudmFyIGluaXRfcGFyc2VfbW92ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXJzMTEgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXlJlbmFtaW5nICguKykgdG8gKC4rKSQvLCAocmVzdWx0LCBbZnJvbSwgdG9dKSA9PiB7XG4gICAgICAgIHJlc3VsdC5tb3Zlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL21vdmUudHNcbnZhciBtb3ZlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1vdmVfZXhwb3J0cywge1xuICBtb3ZlVGFzazogKCkgPT4gbW92ZVRhc2tcbn0pO1xuZnVuY3Rpb24gbW92ZVRhc2soZnJvbSwgdG8pIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogW1wibXZcIiwgXCItdlwiLCAuLi5hc0FycmF5KGZyb20pLCB0b10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZU1vdmVSZXN1bHRcbiAgfTtcbn1cbnZhciBpbml0X21vdmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9tb3ZlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9wYXJzZV9tb3ZlKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9wdWxsLnRzXG52YXIgcHVsbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChwdWxsX2V4cG9ydHMsIHtcbiAgcHVsbFRhc2s6ICgpID0+IHB1bGxUYXNrXG59KTtcbmZ1bmN0aW9uIHB1bGxUYXNrKHJlbW90ZSwgYnJhbmNoLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicHVsbFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKHJlbW90ZSAmJiBicmFuY2gpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVtb3RlLCBicmFuY2gpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICByZXR1cm4gcGFyc2VQdWxsUmVzdWx0KHN0ZE91dCwgc3RkRXJyKTtcbiAgICB9LFxuICAgIG9uRXJyb3IocmVzdWx0LCBfZXJyb3IsIF9kb25lLCBmYWlsKSB7XG4gICAgICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVB1bGxFcnJvclJlc3VsdChcbiAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZE91dCksXG4gICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRFcnIpXG4gICAgICApO1xuICAgICAgaWYgKHB1bGxFcnJvcikge1xuICAgICAgICByZXR1cm4gZmFpbChuZXcgR2l0UmVzcG9uc2VFcnJvcihwdWxsRXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGZhaWwoX2Vycm9yKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9wdWxsID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvcHVsbC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF9wYXJzZV9wdWxsKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeS50c1xuZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzKHRleHQpIHtcbiAgY29uc3QgcmVtb3RlcyA9IHt9O1xuICBmb3JFYWNoKHRleHQsIChbbmFtZV0pID0+IHJlbW90ZXNbbmFtZV0gPSB7IG5hbWUgfSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSh0ZXh0KSB7XG4gIGNvbnN0IHJlbW90ZXMgPSB7fTtcbiAgZm9yRWFjaCh0ZXh0LCAoW25hbWUsIHVybCwgcHVycG9zZV0pID0+IHtcbiAgICBpZiAoIXJlbW90ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJlbW90ZXNbbmFtZV0gPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJlZnM6IHsgZmV0Y2g6IFwiXCIsIHB1c2g6IFwiXCIgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHB1cnBvc2UgJiYgdXJsKSB7XG4gICAgICByZW1vdGVzW25hbWVdLnJlZnNbcHVycG9zZS5yZXBsYWNlKC9bXmEtel0vZywgXCJcIildID0gdXJsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuZnVuY3Rpb24gZm9yRWFjaCh0ZXh0LCBoYW5kbGVyKSB7XG4gIGZvckVhY2hMaW5lV2l0aENvbnRlbnQodGV4dCwgKGxpbmUpID0+IGhhbmRsZXIobGluZS5zcGxpdCgvXFxzKy8pKSk7XG59XG52YXIgaW5pdF9HZXRSZW1vdGVTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0dldFJlbW90ZVN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3JlbW90ZS50c1xudmFyIHJlbW90ZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZW1vdGVfZXhwb3J0cywge1xuICBhZGRSZW1vdGVUYXNrOiAoKSA9PiBhZGRSZW1vdGVUYXNrLFxuICBnZXRSZW1vdGVzVGFzazogKCkgPT4gZ2V0UmVtb3Rlc1Rhc2ssXG4gIGxpc3RSZW1vdGVzVGFzazogKCkgPT4gbGlzdFJlbW90ZXNUYXNrLFxuICByZW1vdGVUYXNrOiAoKSA9PiByZW1vdGVUYXNrLFxuICByZW1vdmVSZW1vdGVUYXNrOiAoKSA9PiByZW1vdmVSZW1vdGVUYXNrXG59KTtcbmZ1bmN0aW9uIGFkZFJlbW90ZVRhc2socmVtb3RlTmFtZSwgcmVtb3RlUmVwbywgY3VzdG9tQXJncykge1xuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJyZW1vdGVcIiwgXCJhZGRcIiwgLi4uY3VzdG9tQXJncywgcmVtb3RlTmFtZSwgcmVtb3RlUmVwb10pO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3Rlc1Rhc2sodmVyYm9zZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJlbW90ZVwiXTtcbiAgaWYgKHZlcmJvc2UpIHtcbiAgICBjb21tYW5kcy5wdXNoKFwiLXZcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHZlcmJvc2UgPyBwYXJzZUdldFJlbW90ZXNWZXJib3NlIDogcGFyc2VHZXRSZW1vdGVzXG4gIH07XG59XG5mdW5jdGlvbiBsaXN0UmVtb3Rlc1Rhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGNvbW1hbmRzWzBdICE9PSBcImxzLXJlbW90ZVwiKSB7XG4gICAgY29tbWFuZHMudW5zaGlmdChcImxzLXJlbW90ZVwiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiByZW1vdGVUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gIGlmIChjb21tYW5kc1swXSAhPT0gXCJyZW1vdGVcIikge1xuICAgIGNvbW1hbmRzLnVuc2hpZnQoXCJyZW1vdGVcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGFzayhyZW1vdGVOYW1lKSB7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcInJlbW90ZVwiLCBcInJlbW92ZVwiLCByZW1vdGVOYW1lXSk7XG59XG52YXIgaW5pdF9yZW1vdGUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9yZW1vdGUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0dldFJlbW90ZVN1bW1hcnkoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3Mvc3Rhc2gtbGlzdC50c1xudmFyIHN0YXNoX2xpc3RfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3Rhc2hfbGlzdF9leHBvcnRzLCB7XG4gIHN0YXNoTGlzdFRhc2s6ICgpID0+IHN0YXNoTGlzdFRhc2tcbn0pO1xuZnVuY3Rpb24gc3Rhc2hMaXN0VGFzayhvcHQgPSB7fSwgY3VzdG9tQXJncykge1xuICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zKG9wdCk7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wic3Rhc2hcIiwgXCJsaXN0XCIsIC4uLm9wdGlvbnMuY29tbWFuZHMsIC4uLmN1c3RvbUFyZ3NdO1xuICBjb25zdCBwYXJzZXI0ID0gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXIoXG4gICAgb3B0aW9ucy5zcGxpdHRlcixcbiAgICBvcHRpb25zLmZpZWxkcyxcbiAgICBsb2dGb3JtYXRGcm9tQ29tbWFuZChjb21tYW5kcylcbiAgKTtcbiAgcmV0dXJuIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGNvbW1hbmRzKSB8fCB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZXI0XG4gIH07XG59XG52YXIgaW5pdF9zdGFzaF9saXN0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc3Rhc2gtbGlzdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfbG9nX2Zvcm1hdCgpO1xuICAgIGluaXRfcGFyc2VfbGlzdF9sb2dfc3VtbWFyeSgpO1xuICAgIGluaXRfZGlmZigpO1xuICAgIGluaXRfbG9nKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3N1Yi1tb2R1bGUudHNcbnZhciBzdWJfbW9kdWxlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN1Yl9tb2R1bGVfZXhwb3J0cywge1xuICBhZGRTdWJNb2R1bGVUYXNrOiAoKSA9PiBhZGRTdWJNb2R1bGVUYXNrLFxuICBpbml0U3ViTW9kdWxlVGFzazogKCkgPT4gaW5pdFN1Yk1vZHVsZVRhc2ssXG4gIHN1Yk1vZHVsZVRhc2s6ICgpID0+IHN1Yk1vZHVsZVRhc2ssXG4gIHVwZGF0ZVN1Yk1vZHVsZVRhc2s6ICgpID0+IHVwZGF0ZVN1Yk1vZHVsZVRhc2tcbn0pO1xuZnVuY3Rpb24gYWRkU3ViTW9kdWxlVGFzayhyZXBvLCBwYXRoKSB7XG4gIHJldHVybiBzdWJNb2R1bGVUYXNrKFtcImFkZFwiLCByZXBvLCBwYXRoXSk7XG59XG5mdW5jdGlvbiBpbml0U3ViTW9kdWxlVGFzayhjdXN0b21BcmdzKSB7XG4gIHJldHVybiBzdWJNb2R1bGVUYXNrKFtcImluaXRcIiwgLi4uY3VzdG9tQXJnc10pO1xufVxuZnVuY3Rpb24gc3ViTW9kdWxlVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICBpZiAoY29tbWFuZHNbMF0gIT09IFwic3VibW9kdWxlXCIpIHtcbiAgICBjb21tYW5kcy51bnNoaWZ0KFwic3VibW9kdWxlXCIpO1xuICB9XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN1Yk1vZHVsZVRhc2soY3VzdG9tQXJncykge1xuICByZXR1cm4gc3ViTW9kdWxlVGFzayhbXCJ1cGRhdGVcIiwgLi4uY3VzdG9tQXJnc10pO1xufVxudmFyIGluaXRfc3ViX21vZHVsZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3N1Yi1tb2R1bGUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL1RhZ0xpc3QudHNcbmZ1bmN0aW9uIHNpbmdsZVNvcnRlZChhLCBiKSB7XG4gIGNvbnN0IGFJc051bSA9IGlzTmFOKGEpO1xuICBjb25zdCBiSXNOdW0gPSBpc05hTihiKTtcbiAgaWYgKGFJc051bSAhPT0gYklzTnVtKSB7XG4gICAgcmV0dXJuIGFJc051bSA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gYUlzTnVtID8gc29ydGVkKGEsIGIpIDogMDtcbn1cbmZ1bmN0aW9uIHNvcnRlZChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gdHJpbW1lZChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQudHJpbSgpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwYXJzZUludChpbnB1dC5yZXBsYWNlKC9eXFxEKy9nLCBcIlwiKSwgMTApIHx8IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgVGFnTGlzdCwgcGFyc2VUYWdMaXN0O1xudmFyIGluaXRfVGFnTGlzdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9UYWdMaXN0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgVGFnTGlzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGFsbCwgbGF0ZXN0KSB7XG4gICAgICAgIHRoaXMuYWxsID0gYWxsO1xuICAgICAgICB0aGlzLmxhdGVzdCA9IGxhdGVzdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlVGFnTGlzdCA9IGZ1bmN0aW9uKGRhdGEsIGN1c3RvbVNvcnQgPSBmYWxzZSkge1xuICAgICAgY29uc3QgdGFncyA9IGRhdGEuc3BsaXQoXCJcXG5cIikubWFwKHRyaW1tZWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGlmICghY3VzdG9tU29ydCkge1xuICAgICAgICB0YWdzLnNvcnQoZnVuY3Rpb24odGFnQSwgdGFnQikge1xuICAgICAgICAgIGNvbnN0IHBhcnRzQSA9IHRhZ0Euc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGNvbnN0IHBhcnRzQiA9IHRhZ0Iuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGlmIChwYXJ0c0EubGVuZ3RoID09PSAxIHx8IHBhcnRzQi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVTb3J0ZWQodG9OdW1iZXIocGFydHNBWzBdKSwgdG9OdW1iZXIocGFydHNCWzBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gTWF0aC5tYXgocGFydHNBLmxlbmd0aCwgcGFydHNCLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzb3J0ZWQodG9OdW1iZXIocGFydHNBW2ldKSwgdG9OdW1iZXIocGFydHNCW2ldKSk7XG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbGF0ZXN0ID0gY3VzdG9tU29ydCA/IHRhZ3NbMF0gOiBbLi4udGFnc10ucmV2ZXJzZSgpLmZpbmQoKHRhZykgPT4gdGFnLmluZGV4T2YoXCIuXCIpID49IDApO1xuICAgICAgcmV0dXJuIG5ldyBUYWdMaXN0KHRhZ3MsIGxhdGVzdCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvdGFnLnRzXG52YXIgdGFnX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRhZ19leHBvcnRzLCB7XG4gIGFkZEFubm90YXRlZFRhZ1Rhc2s6ICgpID0+IGFkZEFubm90YXRlZFRhZ1Rhc2ssXG4gIGFkZFRhZ1Rhc2s6ICgpID0+IGFkZFRhZ1Rhc2ssXG4gIHRhZ0xpc3RUYXNrOiAoKSA9PiB0YWdMaXN0VGFza1xufSk7XG5mdW5jdGlvbiB0YWdMaXN0VGFzayhjdXN0b21BcmdzID0gW10pIHtcbiAgY29uc3QgaGFzQ3VzdG9tU29ydCA9IGN1c3RvbUFyZ3Muc29tZSgob3B0aW9uKSA9PiAvXi0tc29ydD0vLnRlc3Qob3B0aW9uKSk7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcInRhZ1wiLCBcIi1sXCIsIC4uLmN1c3RvbUFyZ3NdLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gcGFyc2VUYWdMaXN0KHRleHQsIGhhc0N1c3RvbVNvcnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZFRhZ1Rhc2sobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJ0YWdcIiwgbmFtZV0sXG4gICAgcGFyc2VyKCkge1xuICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZEFubm90YXRlZFRhZ1Rhc2sobmFtZSwgdGFnTWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJ0YWdcIiwgXCItYVwiLCBcIi1tXCIsIHRhZ01lc3NhZ2UsIG5hbWVdLFxuICAgIHBhcnNlcigpIHtcbiAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF90YWcgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy90YWcudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X1RhZ0xpc3QoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9naXQuanNcbnZhciByZXF1aXJlX2dpdCA9IF9fY29tbW9uSlMoe1xuICBcInNyYy9naXQuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeyBHaXRFeGVjdXRvcjogR2l0RXhlY3V0b3IyIH0gPSAoaW5pdF9naXRfZXhlY3V0b3IoKSwgX190b0NvbW1vbkpTKGdpdF9leGVjdXRvcl9leHBvcnRzKSk7XG4gICAgdmFyIHsgU2ltcGxlR2l0QXBpOiBTaW1wbGVHaXRBcGkyIH0gPSAoaW5pdF9zaW1wbGVfZ2l0X2FwaSgpLCBfX3RvQ29tbW9uSlMoc2ltcGxlX2dpdF9hcGlfZXhwb3J0cykpO1xuICAgIHZhciB7IFNjaGVkdWxlcjogU2NoZWR1bGVyMiB9ID0gKGluaXRfc2NoZWR1bGVyKCksIF9fdG9Db21tb25KUyhzY2hlZHVsZXJfZXhwb3J0cykpO1xuICAgIHZhciB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2s6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2syIH0gPSAoaW5pdF90YXNrKCksIF9fdG9Db21tb25KUyh0YXNrX2V4cG9ydHMpKTtcbiAgICB2YXIge1xuICAgICAgYXNBcnJheTogYXNBcnJheTIsXG4gICAgICBmaWx0ZXJBcnJheTogZmlsdGVyQXJyYXkyLFxuICAgICAgZmlsdGVyUHJpbWl0aXZlczogZmlsdGVyUHJpbWl0aXZlczIsXG4gICAgICBmaWx0ZXJTdHJpbmc6IGZpbHRlclN0cmluZzIsXG4gICAgICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5MixcbiAgICAgIGZpbHRlclR5cGU6IGZpbHRlclR5cGUyLFxuICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zOiBnZXRUcmFpbGluZ09wdGlvbnMyLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50OiB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyLFxuICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQ6IHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50MlxuICAgIH0gPSAoaW5pdF91dGlscygpLCBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cykpO1xuICAgIHZhciB7IGFwcGx5UGF0Y2hUYXNrOiBhcHBseVBhdGNoVGFzazIgfSA9IChpbml0X2FwcGx5X3BhdGNoKCksIF9fdG9Db21tb25KUyhhcHBseV9wYXRjaF9leHBvcnRzKSk7XG4gICAgdmFyIHtcbiAgICAgIGJyYW5jaFRhc2s6IGJyYW5jaFRhc2syLFxuICAgICAgYnJhbmNoTG9jYWxUYXNrOiBicmFuY2hMb2NhbFRhc2syLFxuICAgICAgZGVsZXRlQnJhbmNoZXNUYXNrOiBkZWxldGVCcmFuY2hlc1Rhc2syLFxuICAgICAgZGVsZXRlQnJhbmNoVGFzazogZGVsZXRlQnJhbmNoVGFzazJcbiAgICB9ID0gKGluaXRfYnJhbmNoKCksIF9fdG9Db21tb25KUyhicmFuY2hfZXhwb3J0cykpO1xuICAgIHZhciB7IGNoZWNrSWdub3JlVGFzazogY2hlY2tJZ25vcmVUYXNrMiB9ID0gKGluaXRfY2hlY2tfaWdub3JlKCksIF9fdG9Db21tb25KUyhjaGVja19pZ25vcmVfZXhwb3J0cykpO1xuICAgIHZhciB7IGNoZWNrSXNSZXBvVGFzazogY2hlY2tJc1JlcG9UYXNrMiB9ID0gKGluaXRfY2hlY2tfaXNfcmVwbygpLCBfX3RvQ29tbW9uSlMoY2hlY2tfaXNfcmVwb19leHBvcnRzKSk7XG4gICAgdmFyIHsgY2xvbmVUYXNrOiBjbG9uZVRhc2syLCBjbG9uZU1pcnJvclRhc2s6IGNsb25lTWlycm9yVGFzazIgfSA9IChpbml0X2Nsb25lKCksIF9fdG9Db21tb25KUyhjbG9uZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgY2xlYW5XaXRoT3B0aW9uc1Rhc2s6IGNsZWFuV2l0aE9wdGlvbnNUYXNrMiwgaXNDbGVhbk9wdGlvbnNBcnJheTogaXNDbGVhbk9wdGlvbnNBcnJheTIgfSA9IChpbml0X2NsZWFuKCksIF9fdG9Db21tb25KUyhjbGVhbl9leHBvcnRzKSk7XG4gICAgdmFyIHsgZGlmZlN1bW1hcnlUYXNrOiBkaWZmU3VtbWFyeVRhc2syIH0gPSAoaW5pdF9kaWZmKCksIF9fdG9Db21tb25KUyhkaWZmX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBmZXRjaFRhc2s6IGZldGNoVGFzazIgfSA9IChpbml0X2ZldGNoKCksIF9fdG9Db21tb25KUyhmZXRjaF9leHBvcnRzKSk7XG4gICAgdmFyIHsgbW92ZVRhc2s6IG1vdmVUYXNrMiB9ID0gKGluaXRfbW92ZSgpLCBfX3RvQ29tbW9uSlMobW92ZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgcHVsbFRhc2s6IHB1bGxUYXNrMiB9ID0gKGluaXRfcHVsbCgpLCBfX3RvQ29tbW9uSlMocHVsbF9leHBvcnRzKSk7XG4gICAgdmFyIHsgcHVzaFRhZ3NUYXNrOiBwdXNoVGFnc1Rhc2syIH0gPSAoaW5pdF9wdXNoKCksIF9fdG9Db21tb25KUyhwdXNoX2V4cG9ydHMpKTtcbiAgICB2YXIge1xuICAgICAgYWRkUmVtb3RlVGFzazogYWRkUmVtb3RlVGFzazIsXG4gICAgICBnZXRSZW1vdGVzVGFzazogZ2V0UmVtb3Rlc1Rhc2syLFxuICAgICAgbGlzdFJlbW90ZXNUYXNrOiBsaXN0UmVtb3Rlc1Rhc2syLFxuICAgICAgcmVtb3RlVGFzazogcmVtb3RlVGFzazIsXG4gICAgICByZW1vdmVSZW1vdGVUYXNrOiByZW1vdmVSZW1vdGVUYXNrMlxuICAgIH0gPSAoaW5pdF9yZW1vdGUoKSwgX190b0NvbW1vbkpTKHJlbW90ZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgZ2V0UmVzZXRNb2RlOiBnZXRSZXNldE1vZGUyLCByZXNldFRhc2s6IHJlc2V0VGFzazIgfSA9IChpbml0X3Jlc2V0KCksIF9fdG9Db21tb25KUyhyZXNldF9leHBvcnRzKSk7XG4gICAgdmFyIHsgc3Rhc2hMaXN0VGFzazogc3Rhc2hMaXN0VGFzazIgfSA9IChpbml0X3N0YXNoX2xpc3QoKSwgX190b0NvbW1vbkpTKHN0YXNoX2xpc3RfZXhwb3J0cykpO1xuICAgIHZhciB7XG4gICAgICBhZGRTdWJNb2R1bGVUYXNrOiBhZGRTdWJNb2R1bGVUYXNrMixcbiAgICAgIGluaXRTdWJNb2R1bGVUYXNrOiBpbml0U3ViTW9kdWxlVGFzazIsXG4gICAgICBzdWJNb2R1bGVUYXNrOiBzdWJNb2R1bGVUYXNrMixcbiAgICAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2s6IHVwZGF0ZVN1Yk1vZHVsZVRhc2syXG4gICAgfSA9IChpbml0X3N1Yl9tb2R1bGUoKSwgX190b0NvbW1vbkpTKHN1Yl9tb2R1bGVfZXhwb3J0cykpO1xuICAgIHZhciB7IGFkZEFubm90YXRlZFRhZ1Rhc2s6IGFkZEFubm90YXRlZFRhZ1Rhc2syLCBhZGRUYWdUYXNrOiBhZGRUYWdUYXNrMiwgdGFnTGlzdFRhc2s6IHRhZ0xpc3RUYXNrMiB9ID0gKGluaXRfdGFnKCksIF9fdG9Db21tb25KUyh0YWdfZXhwb3J0cykpO1xuICAgIHZhciB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2s6IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2syLCBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMiB9ID0gKGluaXRfdGFzaygpLCBfX3RvQ29tbW9uSlModGFza19leHBvcnRzKSk7XG4gICAgZnVuY3Rpb24gR2l0MihvcHRpb25zLCBwbHVnaW5zKSB7XG4gICAgICB0aGlzLl9wbHVnaW5zID0gcGx1Z2lucztcbiAgICAgIHRoaXMuX2V4ZWN1dG9yID0gbmV3IEdpdEV4ZWN1dG9yMihcbiAgICAgICAgb3B0aW9ucy5iYXNlRGlyLFxuICAgICAgICBuZXcgU2NoZWR1bGVyMihvcHRpb25zLm1heENvbmN1cnJlbnRQcm9jZXNzZXMpLFxuICAgICAgICBwbHVnaW5zXG4gICAgICApO1xuICAgICAgdGhpcy5fdHJpbW1lZCA9IG9wdGlvbnMudHJpbW1lZDtcbiAgICB9XG4gICAgKEdpdDIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaW1wbGVHaXRBcGkyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gR2l0MjtcbiAgICBHaXQyLnByb3RvdHlwZS5jdXN0b21CaW5hcnkgPSBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgICB0aGlzLl9wbHVnaW5zLnJlY29uZmlndXJlKFwiYmluYXJ5XCIsIGNvbW1hbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5lbnYgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3IuZW52ID0gbmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh0aGlzLl9leGVjdXRvci5lbnYgPSB0aGlzLl9leGVjdXRvci5lbnYgfHwge30pW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnN0YXNoTGlzdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdGFzaExpc3RUYXNrMihcbiAgICAgICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudDIoYXJndW1lbnRzKSB8fCB7fSxcbiAgICAgICAgICBmaWx0ZXJBcnJheTIob3B0aW9ucykgJiYgb3B0aW9ucyB8fCBbXVxuICAgICAgICApLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVDbG9uZVRhc2soYXBpLCB0YXNrLCByZXBvUGF0aCwgbG9jYWxQYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcG9QYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrMihgZ2l0LiR7YXBpfSgpIHJlcXVpcmVzIGEgc3RyaW5nICdyZXBvUGF0aCdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXNrKHJlcG9QYXRoLCBmaWx0ZXJUeXBlMihsb2NhbFBhdGgsIGZpbHRlclN0cmluZzIpLCBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBHaXQyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNyZWF0ZUNsb25lVGFzayhcImNsb25lXCIsIGNsb25lVGFzazIsIC4uLmFyZ3VtZW50cyksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLm1pcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNyZWF0ZUNsb25lVGFzayhcIm1pcnJvclwiLCBjbG9uZU1pcnJvclRhc2syLCAuLi5hcmd1bWVudHMpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5tdiA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhtb3ZlVGFzazIoZnJvbSwgdG8pLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2hlY2tvdXRMYXRlc3RUYWcgPSBmdW5jdGlvbih0aGVuKSB7XG4gICAgICB2YXIgZ2l0ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLnB1bGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGdpdC50YWdzKGZ1bmN0aW9uKGVyciwgdGFncykge1xuICAgICAgICAgIGdpdC5jaGVja291dCh0YWdzLmxhdGVzdCwgdGhlbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24ocmVtb3RlLCBicmFuY2gsIG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBwdWxsVGFzazIoXG4gICAgICAgICAgZmlsdGVyVHlwZTIocmVtb3RlLCBmaWx0ZXJTdHJpbmcyKSxcbiAgICAgICAgICBmaWx0ZXJUeXBlMihicmFuY2gsIGZpbHRlclN0cmluZzIpLFxuICAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKVxuICAgICAgICApLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKHJlbW90ZSwgYnJhbmNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZmV0Y2hUYXNrMihcbiAgICAgICAgICBmaWx0ZXJUeXBlMihyZW1vdGUsIGZpbHRlclN0cmluZzIpLFxuICAgICAgICAgIGZpbHRlclR5cGUyKGJyYW5jaCwgZmlsdGVyU3RyaW5nMiksXG4gICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uKHNpbGVuY2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogZ2l0LnNpbGVudDogbG9nZ2luZyBzaG91bGQgYmUgY29uZmlndXJlZCB1c2luZyB0aGUgYGRlYnVnYCBsaWJyYXJ5IC8gYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgdGhpcyB3aWxsIGJlIGFuIGVycm9yIGluIHZlcnNpb24gM1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHRhZ0xpc3RUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZWJhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJyZWJhc2VcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHJlc2V0VGFzazIoZ2V0UmVzZXRNb2RlMihtb2RlKSwgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24oY29tbWl0KSB7XG4gICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpO1xuICAgICAgaWYgKHR5cGVvZiBjb21taXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJDb21taXQgbXVzdCBiZSBhIHN0cmluZ1wiKSwgbmV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wicmV2ZXJ0XCIsIC4uLmdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCAwLCB0cnVlKSwgY29tbWl0XSksXG4gICAgICAgIG5leHRcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5hZGRUYWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBjb25zdCB0YXNrID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyBhZGRUYWdUYXNrMihuYW1lKSA6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKFwiR2l0LmFkZFRhZyByZXF1aXJlcyBhIHRhZyBuYW1lXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFkZEFubm90YXRlZFRhZyA9IGZ1bmN0aW9uKHRhZ05hbWUsIHRhZ01lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBhZGRBbm5vdGF0ZWRUYWdUYXNrMih0YWdOYW1lLCB0YWdNZXNzYWdlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2ggPSBmdW5jdGlvbihicmFuY2hOYW1lLCBmb3JjZURlbGV0ZSwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGRlbGV0ZUJyYW5jaFRhc2syKGJyYW5jaE5hbWUsIHR5cGVvZiBmb3JjZURlbGV0ZSA9PT0gXCJib29sZWFuXCIgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2hlcyA9IGZ1bmN0aW9uKGJyYW5jaE5hbWVzLCBmb3JjZURlbGV0ZSwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGRlbGV0ZUJyYW5jaGVzVGFzazIoYnJhbmNoTmFtZXMsIHR5cGVvZiBmb3JjZURlbGV0ZSA9PT0gXCJib29sZWFuXCIgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGJyYW5jaFRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmJyYW5jaExvY2FsID0gZnVuY3Rpb24odGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soYnJhbmNoTG9jYWxUYXNrMigpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24oY29tbWFuZHMpIHtcbiAgICAgIGNvbnN0IGNyZWF0ZVJlc3RDb21tYW5kcyA9ICFBcnJheS5pc0FycmF5KGNvbW1hbmRzKTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBbXS5zbGljZS5jYWxsKGNyZWF0ZVJlc3RDb21tYW5kcyA/IGFyZ3VtZW50cyA6IGNvbW1hbmRzLCAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZC5sZW5ndGggJiYgY3JlYXRlUmVzdENvbW1hbmRzOyBpKyspIHtcbiAgICAgICAgaWYgKCFmaWx0ZXJQcmltaXRpdmVzMihjb21tYW5kW2ldKSkge1xuICAgICAgICAgIGNvbW1hbmQuc3BsaWNlKGksIGNvbW1hbmQubGVuZ3RoIC0gaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbW1hbmQucHVzaCguLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgMCwgdHJ1ZSkpO1xuICAgICAgdmFyIG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cyk7XG4gICAgICBpZiAoIWNvbW1hbmQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKFwiUmF3OiBtdXN0IHN1cHBseSBvbmUgb3IgbW9yZSBjb21tYW5kIHRvIGV4ZWN1dGVcIiksXG4gICAgICAgICAgbmV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZCwgdGhpcy5fdHJpbW1lZCksIG5leHQpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3VibW9kdWxlQWRkID0gZnVuY3Rpb24ocmVwbywgcGF0aCwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soYWRkU3ViTW9kdWxlVGFzazIocmVwbywgcGF0aCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJtb2R1bGVVcGRhdGUgPSBmdW5jdGlvbihhcmdzLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgdXBkYXRlU3ViTW9kdWxlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIHRydWUpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3VibW9kdWxlSW5pdCA9IGZ1bmN0aW9uKGFyZ3MsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBpbml0U3ViTW9kdWxlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIHRydWUpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3ViTW9kdWxlID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN1Yk1vZHVsZVRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmxpc3RSZW1vdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBsaXN0UmVtb3Rlc1Rhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFkZFJlbW90ZSA9IGZ1bmN0aW9uKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBhZGRSZW1vdGVUYXNrMihyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZW1vdmVSZW1vdGUgPSBmdW5jdGlvbihyZW1vdGVOYW1lLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhyZW1vdmVSZW1vdGVUYXNrMihyZW1vdGVOYW1lKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmdldFJlbW90ZXMgPSBmdW5jdGlvbih2ZXJib3NlLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhnZXRSZW1vdGVzVGFzazIodmVyYm9zZSA9PT0gdHJ1ZSksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZW1vdGUgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgcmVtb3RlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24ob3B0aW9ucywgdGhlbikge1xuICAgICAgY29uc3QgY29tbWFuZCA9IGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKTtcbiAgICAgIGlmIChjb21tYW5kWzBdICE9PSBcInRhZ1wiKSB7XG4gICAgICAgIGNvbW1hbmQudW5zaGlmdChcInRhZ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKGNvbW1hbmQpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUudXBkYXRlU2VydmVySW5mbyA9IGZ1bmN0aW9uKHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJ1cGRhdGUtc2VydmVyLWluZm9cIl0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5wdXNoVGFncyA9IGZ1bmN0aW9uKHJlbW90ZSwgdGhlbikge1xuICAgICAgY29uc3QgdGFzayA9IHB1c2hUYWdzVGFzazIoXG4gICAgICAgIHsgcmVtb3RlOiBmaWx0ZXJUeXBlMihyZW1vdGUsIGZpbHRlclN0cmluZzIpIH0sXG4gICAgICAgIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5ybSA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wicm1cIiwgXCItZlwiLCAuLi5hc0FycmF5MihmaWxlcyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucm1LZWVwTG9jYWwgPSBmdW5jdGlvbihmaWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcInJtXCIsIFwiLS1jYWNoZWRcIiwgLi4uYXNBcnJheTIoZmlsZXMpXSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmNhdEZpbGUgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2F0RmlsZShcInV0Zi04XCIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5iaW5hcnlDYXRGaWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2F0RmlsZShcImJ1ZmZlclwiLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuX2NhdEZpbGUgPSBmdW5jdGlvbihmb3JtYXQsIGFyZ3MpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50MihhcmdzKTtcbiAgICAgIHZhciBjb21tYW5kID0gW1wiY2F0LWZpbGVcIl07XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJHaXQuY2F0RmlsZTogb3B0aW9ucyBtdXN0IGJlIHN1cHBsaWVkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcIiksXG4gICAgICAgICAgaGFuZGxlclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgY29tbWFuZC5wdXNoLmFwcGx5KGNvbW1hbmQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFzayA9IGZvcm1hdCA9PT0gXCJidWZmZXJcIiA/IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2syKGNvbW1hbmQpIDogc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZCk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICBjb25zdCB0YXNrID0gZmlsdGVyU3RyaW5nMihvcHRpb25zKSA/IGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKFxuICAgICAgICBcImdpdC5kaWZmOiBzdXBwbHlpbmcgb3B0aW9ucyBhcyBhIHNpbmdsZSBzdHJpbmcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgc3dpdGNoIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcIlxuICAgICAgKSA6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcImRpZmZcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXSk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGlmZlN1bW1hcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBkaWZmU3VtbWFyeVRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCAxKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFwcGx5UGF0Y2ggPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gICAgICBjb25zdCB0YXNrID0gIWZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkyKHBhdGNoZXMpID8gY29uZmlndXJhdGlvbkVycm9yVGFzazIoXG4gICAgICAgIGBnaXQuYXBwbHlQYXRjaCByZXF1aXJlcyBvbmUgb3IgbW9yZSBzdHJpbmcgcGF0Y2hlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnRgXG4gICAgICApIDogYXBwbHlQYXRjaFRhc2syKGFzQXJyYXkyKHBhdGNoZXMpLCBnZXRUcmFpbGluZ09wdGlvbnMyKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJldnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgdHJ1ZSldO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKGNvbW1hbmRzLCB0cnVlKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbihtb2RlLCBvcHRpb25zLCB0aGVuKSB7XG4gICAgICBjb25zdCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID0gaXNDbGVhbk9wdGlvbnNBcnJheTIobW9kZSk7XG4gICAgICBjb25zdCBjbGVhbk1vZGUgPSB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ICYmIG1vZGUuam9pbihcIlwiKSB8fCBmaWx0ZXJUeXBlMihtb2RlLCBmaWx0ZXJTdHJpbmcyKSB8fCBcIlwiO1xuICAgICAgY29uc3QgY3VzdG9tQXJncyA9IGdldFRyYWlsaW5nT3B0aW9uczIoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgPyAxIDogMCkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNsZWFuV2l0aE9wdGlvbnNUYXNrMihjbGVhbk1vZGUsIGN1c3RvbUFyZ3MpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24odGhlbikge1xuICAgICAgY29uc3QgdGFzayA9IHtcbiAgICAgICAgY29tbWFuZHM6IFtdLFxuICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzayk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jbGVhclF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmNoZWNrSWdub3JlID0gZnVuY3Rpb24ocGF0aG5hbWVzLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY2hlY2tJZ25vcmVUYXNrMihhc0FycmF5MihmaWx0ZXJUeXBlMihwYXRobmFtZXMsIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkyLCBbXSkpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2hlY2tJc1JlcG8gPSBmdW5jdGlvbihjaGVja1R5cGUsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja0lzUmVwb1Rhc2syKGZpbHRlclR5cGUyKGNoZWNrVHlwZSwgZmlsdGVyU3RyaW5nMikpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdpdDI7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2FwaS50c1xuaW5pdF9wYXRoc3BlYygpO1xuXG4vLyBzcmMvbGliL2Vycm9ycy9naXQtY29uc3RydWN0LWVycm9yLnRzXG5pbml0X2dpdF9lcnJvcigpO1xudmFyIEdpdENvbnN0cnVjdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgbWVzc2FnZSkge1xuICAgIHN1cGVyKHZvaWQgMCwgbWVzc2FnZSk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvYXBpLnRzXG5pbml0X2dpdF9lcnJvcigpO1xuXG4vLyBzcmMvbGliL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yLnRzXG5pbml0X2dpdF9lcnJvcigpO1xudmFyIEdpdFBsdWdpbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHRhc2ssIHBsdWdpbiwgbWVzc2FnZSkge1xuICAgIHN1cGVyKHRhc2ssIG1lc3NhZ2UpO1xuICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hcGkudHNcbmluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG5pbml0X3Rhc2tfY29uZmlndXJhdGlvbl9lcnJvcigpO1xuaW5pdF9jaGVja19pc19yZXBvKCk7XG5pbml0X2NsZWFuKCk7XG5pbml0X2NvbmZpZygpO1xuaW5pdF9kaWZmX25hbWVfc3RhdHVzKCk7XG5pbml0X2dyZXAoKTtcbmluaXRfcmVzZXQoKTtcblxuLy8gc3JjL2xpYi9wbHVnaW5zL2Fib3J0LXBsdWdpbi50c1xuZnVuY3Rpb24gYWJvcnRQbHVnaW4oc2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9uU3Bhd25BZnRlciA9IHtcbiAgICB0eXBlOiBcInNwYXduLmFmdGVyXCIsXG4gICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJhYm9ydFwiLCBcIkFib3J0IHNpZ25hbCByZWNlaXZlZFwiKSk7XG4gICAgICB9XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGtpbGwpO1xuICAgICAgY29udGV4dC5zcGF3bmVkLm9uKFwiY2xvc2VcIiwgKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBraWxsKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvblNwYXduQmVmb3JlID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYmVmb3JlXCIsXG4gICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwiYWJvcnRcIiwgXCJBYm9ydCBhbHJlYWR5IHNpZ25hbGVkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbb25TcGF3bkJlZm9yZSwgb25TcGF3bkFmdGVyXTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2Jsb2NrLXVuc2FmZS1vcGVyYXRpb25zLXBsdWdpbi50c1xuZnVuY3Rpb24gaXNDb25maWdTd2l0Y2goYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiICYmIGFyZy50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gXCItY1wiO1xufVxuZnVuY3Rpb24gcHJldmVudFByb3RvY29sT3ZlcnJpZGUoYXJnLCBuZXh0KSB7XG4gIGlmICghaXNDb25maWdTd2l0Y2goYXJnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIS9eXFxzKnByb3RvY29sKC5bYS16XSspPy5hbGxvdy8udGVzdChuZXh0KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgdm9pZCAwLFxuICAgIFwidW5zYWZlXCIsXG4gICAgXCJDb25maWd1cmluZyBwcm90b2NvbC5hbGxvdyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVFeHRQcm90b2NvbFwiXG4gICk7XG59XG5mdW5jdGlvbiBwcmV2ZW50VXBsb2FkUGFjayhhcmcsIG1ldGhvZCkge1xuICBpZiAoL15cXHMqLS0odXBsb2FkfHJlY2VpdmUpLXBhY2svLnRlc3QoYXJnKSkge1xuICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgIHZvaWQgMCxcbiAgICAgIFwidW5zYWZlXCIsXG4gICAgICBgVXNlIG9mIC0tdXBsb2FkLXBhY2sgb3IgLS1yZWNlaXZlLXBhY2sgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICApO1xuICB9XG4gIGlmIChtZXRob2QgPT09IFwiY2xvbmVcIiAmJiAvXlxccyotdVxcYi8udGVzdChhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdm9pZCAwLFxuICAgICAgXCJ1bnNhZmVcIixcbiAgICAgIGBVc2Ugb2YgY2xvbmUgd2l0aCBvcHRpb24gLXUgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICApO1xuICB9XG4gIGlmIChtZXRob2QgPT09IFwicHVzaFwiICYmIC9eXFxzKi0tZXhlY1xcYi8udGVzdChhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdm9pZCAwLFxuICAgICAgXCJ1bnNhZmVcIixcbiAgICAgIGBVc2Ugb2YgcHVzaCB3aXRoIG9wdGlvbiAtLWV4ZWMgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oe1xuICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgPSBmYWxzZSxcbiAgYWxsb3dVbnNhZmVQYWNrID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYXJnc1wiLFxuICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICBhcmdzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBpbmRleCA8IGFyZ3MubGVuZ3RoID8gYXJnc1tpbmRleCArIDFdIDogXCJcIjtcbiAgICAgICAgYWxsb3dVbnNhZmVQcm90b2NvbE92ZXJyaWRlIHx8IHByZXZlbnRQcm90b2NvbE92ZXJyaWRlKGN1cnJlbnQsIG5leHQpO1xuICAgICAgICBhbGxvd1Vuc2FmZVBhY2sgfHwgcHJldmVudFVwbG9hZFBhY2soY3VycmVudCwgY29udGV4dC5tZXRob2QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9jb21tYW5kLWNvbmZpZy1wcmVmaXhpbmctcGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5mdW5jdGlvbiBjb21tYW5kQ29uZmlnUHJlZml4aW5nUGx1Z2luKGNvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgcHJlZml4ID0gcHJlZml4ZWRBcnJheShjb25maWd1cmF0aW9uLCBcIi1jXCIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYXJnc1wiLFxuICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gWy4uLnByZWZpeCwgLi4uZGF0YV07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvY29tcGxldGlvbi1kZXRlY3Rpb24ucGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5pbXBvcnQgeyBkZWZlcnJlZCB9IGZyb20gXCJAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkXCI7XG52YXIgbmV2ZXIgPSBkZWZlcnJlZCgpLnByb21pc2U7XG5mdW5jdGlvbiBjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKHtcbiAgb25DbG9zZSA9IHRydWUsXG4gIG9uRXhpdCA9IDUwXG59ID0ge30pIHtcbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRzKCkge1xuICAgIGxldCBleGl0Q29kZSA9IC0xO1xuICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgIGNsb3NlOiBkZWZlcnJlZCgpLFxuICAgICAgY2xvc2VUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgZXhpdDogZGVmZXJyZWQoKSxcbiAgICAgIGV4aXRUaW1lb3V0OiBkZWZlcnJlZCgpXG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBQcm9taXNlLnJhY2UoW1xuICAgICAgb25DbG9zZSA9PT0gZmFsc2UgPyBuZXZlciA6IGV2ZW50cy5jbG9zZVRpbWVvdXQucHJvbWlzZSxcbiAgICAgIG9uRXhpdCA9PT0gZmFsc2UgPyBuZXZlciA6IGV2ZW50cy5leGl0VGltZW91dC5wcm9taXNlXG4gICAgXSk7XG4gICAgY29uZmlndXJlVGltZW91dChvbkNsb3NlLCBldmVudHMuY2xvc2UsIGV2ZW50cy5jbG9zZVRpbWVvdXQpO1xuICAgIGNvbmZpZ3VyZVRpbWVvdXQob25FeGl0LCBldmVudHMuZXhpdCwgZXZlbnRzLmV4aXRUaW1lb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2UoY29kZSkge1xuICAgICAgICBleGl0Q29kZSA9IGNvZGU7XG4gICAgICAgIGV2ZW50cy5jbG9zZS5kb25lKCk7XG4gICAgICB9LFxuICAgICAgZXhpdChjb2RlKSB7XG4gICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgZXZlbnRzLmV4aXQuZG9uZSgpO1xuICAgICAgfSxcbiAgICAgIGdldCBleGl0Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIGV4aXRDb2RlO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY29uZmlndXJlVGltZW91dChmbGFnLCBldmVudCwgdGltZW91dCkge1xuICAgIGlmIChmbGFnID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoZmxhZyA9PT0gdHJ1ZSA/IGV2ZW50LnByb21pc2UgOiBldmVudC5wcm9taXNlLnRoZW4oKCkgPT4gZGVsYXkoZmxhZykpKS50aGVuKHRpbWVvdXQuZG9uZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwYXduLmFmdGVyXCIsXG4gICAgYWN0aW9uKF8wLCBfMSkge1xuICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKF9kYXRhLCB7IHNwYXduZWQsIGNsb3NlIH0pIHtcbiAgICAgICAgdmFyIF9hMywgX2I7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGNyZWF0ZUV2ZW50cygpO1xuICAgICAgICBsZXQgZGVmZXJDbG9zZSA9IHRydWU7XG4gICAgICAgIGxldCBxdWlja0Nsb3NlID0gKCkgPT4gdm9pZCAoZGVmZXJDbG9zZSA9IGZhbHNlKTtcbiAgICAgICAgKF9hMyA9IHNwYXduZWQuc3Rkb3V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm9uKFwiZGF0YVwiLCBxdWlja0Nsb3NlKTtcbiAgICAgICAgKF9iID0gc3Bhd25lZC5zdGRlcnIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vbihcImRhdGFcIiwgcXVpY2tDbG9zZSk7XG4gICAgICAgIHNwYXduZWQub24oXCJlcnJvclwiLCBxdWlja0Nsb3NlKTtcbiAgICAgICAgc3Bhd25lZC5vbihcImNsb3NlXCIsIChjb2RlKSA9PiBldmVudHMuY2xvc2UoY29kZSkpO1xuICAgICAgICBzcGF3bmVkLm9uKFwiZXhpdFwiLCAoY29kZSkgPT4gZXZlbnRzLmV4aXQoY29kZSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIGV2ZW50cy5yZXN1bHQ7XG4gICAgICAgICAgaWYgKGRlZmVyQ2xvc2UpIHtcbiAgICAgICAgICAgIHlpZWxkIGRlbGF5KDUwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xvc2UoZXZlbnRzLmV4aXRDb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2xvc2UoZXZlbnRzLmV4aXRDb2RlLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9jdXN0b20tYmluYXJ5LnBsdWdpbi50c1xuaW5pdF91dGlscygpO1xudmFyIFdST05HX05VTUJFUl9FUlIgPSBgSW52YWxpZCB2YWx1ZSBzdXBwbGllZCBmb3IgY3VzdG9tIGJpbmFyeSwgcmVxdWlyZXMgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIG9uZSBvciB0d28gc3RyaW5nc2A7XG52YXIgV1JPTkdfQ0hBUlNfRVJSID0gYEludmFsaWQgdmFsdWUgc3VwcGxpZWQgZm9yIGN1c3RvbSBiaW5hcnksIHJlc3RyaWN0ZWQgY2hhcmFjdGVycyBtdXN0IGJlIHJlbW92ZWQgb3Igc3VwcGx5IHRoZSB1bnNhZmUuYWxsb3dVbnNhZmVDdXN0b21CaW5hcnkgb3B0aW9uYDtcbmZ1bmN0aW9uIGlzQmFkQXJndW1lbnQoYXJnKSB7XG4gIHJldHVybiAhYXJnIHx8ICEvXihbYS16XTopPyhbYS16MC05Ly5cXFxcXy1dKykkL2kudGVzdChhcmcpO1xufVxuZnVuY3Rpb24gdG9CaW5hcnlDb25maWcoaW5wdXQsIGFsbG93VW5zYWZlKSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPCAxIHx8IGlucHV0Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3Iodm9pZCAwLCBcImJpbmFyeVwiLCBXUk9OR19OVU1CRVJfRVJSKTtcbiAgfVxuICBjb25zdCBpc0JhZCA9IGlucHV0LnNvbWUoaXNCYWRBcmd1bWVudCk7XG4gIGlmIChpc0JhZCkge1xuICAgIGlmIChhbGxvd1Vuc2FmZSkge1xuICAgICAgY29uc29sZS53YXJuKFdST05HX0NIQVJTX0VSUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwiYmluYXJ5XCIsIFdST05HX0NIQVJTX0VSUik7XG4gICAgfVxuICB9XG4gIGNvbnN0IFtiaW5hcnksIHByZWZpeF0gPSBpbnB1dDtcbiAgcmV0dXJuIHtcbiAgICBiaW5hcnksXG4gICAgcHJlZml4XG4gIH07XG59XG5mdW5jdGlvbiBjdXN0b21CaW5hcnlQbHVnaW4ocGx1Z2lucywgaW5wdXQgPSBbXCJnaXRcIl0sIGFsbG93VW5zYWZlID0gZmFsc2UpIHtcbiAgbGV0IGNvbmZpZyA9IHRvQmluYXJ5Q29uZmlnKGFzQXJyYXkoaW5wdXQpLCBhbGxvd1Vuc2FmZSk7XG4gIHBsdWdpbnMub24oXCJiaW5hcnlcIiwgKGlucHV0MikgPT4ge1xuICAgIGNvbmZpZyA9IHRvQmluYXJ5Q29uZmlnKGFzQXJyYXkoaW5wdXQyKSwgYWxsb3dVbnNhZmUpO1xuICB9KTtcbiAgcGx1Z2lucy5hcHBlbmQoXCJzcGF3bi5iaW5hcnlcIiwgKCkgPT4ge1xuICAgIHJldHVybiBjb25maWcuYmluYXJ5O1xuICB9KTtcbiAgcGx1Z2lucy5hcHBlbmQoXCJzcGF3bi5hcmdzXCIsIChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy5wcmVmaXggPyBbY29uZmlnLnByZWZpeCwgLi4uZGF0YV0gOiBkYXRhO1xuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2Vycm9yLWRldGVjdGlvbi5wbHVnaW4udHNcbmluaXRfZ2l0X2Vycm9yKCk7XG5mdW5jdGlvbiBpc1Rhc2tFcnJvcihyZXN1bHQpIHtcbiAgcmV0dXJuICEhKHJlc3VsdC5leGl0Q29kZSAmJiByZXN1bHQuc3RkRXJyLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UocmVzdWx0KSB7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFsuLi5yZXN1bHQuc3RkT3V0LCAuLi5yZXN1bHQuc3RkRXJyXSk7XG59XG5mdW5jdGlvbiBlcnJvckRldGVjdGlvbkhhbmRsZXIob3ZlcndyaXRlID0gZmFsc2UsIGlzRXJyb3IgPSBpc1Rhc2tFcnJvciwgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKSB7XG4gIHJldHVybiAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghb3ZlcndyaXRlICYmIGVycm9yIHx8ICFpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZShyZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gZXJyb3JEZXRlY3Rpb25QbHVnaW4oY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0YXNrLmVycm9yXCIsXG4gICAgYWN0aW9uKGRhdGEsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gY29uZmlnKGRhdGEuZXJyb3IsIHtcbiAgICAgICAgc3RkRXJyOiBjb250ZXh0LnN0ZEVycixcbiAgICAgICAgc3RkT3V0OiBjb250ZXh0LnN0ZE91dCxcbiAgICAgICAgZXhpdENvZGU6IGNvbnRleHQuZXhpdENvZGVcbiAgICAgIH0pO1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBHaXRFcnJvcih2b2lkIDAsIGVycm9yLnRvU3RyaW5nKFwidXRmLThcIikpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9wbHVnaW4tc3RvcmUudHNcbmluaXRfdXRpbHMoKTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJub2RlOmV2ZW50c1wiO1xudmFyIFBsdWdpblN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB9XG4gIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudHMub24odHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlY29uZmlndXJlKHR5cGUsIGRhdGEpIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KHR5cGUsIGRhdGEpO1xuICB9XG4gIGFwcGVuZCh0eXBlLCBhY3Rpb24pIHtcbiAgICBjb25zdCBwbHVnaW4gPSBhcHBlbmQodGhpcy5wbHVnaW5zLCB7IHR5cGUsIGFjdGlvbiB9KTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5wbHVnaW5zLmRlbGV0ZShwbHVnaW4pO1xuICB9XG4gIGFkZChwbHVnaW4pIHtcbiAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgYXNBcnJheShwbHVnaW4pLmZvckVhY2goKHBsdWdpbjIpID0+IHBsdWdpbjIgJiYgdGhpcy5wbHVnaW5zLmFkZChhcHBlbmQocGx1Z2lucywgcGx1Z2luMikpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4yKSA9PiB0aGlzLnBsdWdpbnMuZGVsZXRlKHBsdWdpbjIpKTtcbiAgICB9O1xuICB9XG4gIGV4ZWModHlwZSwgZGF0YSwgY29udGV4dCkge1xuICAgIGxldCBvdXRwdXQgPSBkYXRhO1xuICAgIGNvbnN0IGNvbnRleHR1YWwgPSBPYmplY3QuZnJlZXplKE9iamVjdC5jcmVhdGUoY29udGV4dCkpO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHBsdWdpbi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIG91dHB1dCA9IHBsdWdpbi5hY3Rpb24ob3V0cHV0LCBjb250ZXh0dWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9wbHVnaW5zL3Byb2dyZXNzLW1vbml0b3ItcGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5mdW5jdGlvbiBwcm9ncmVzc01vbml0b3JQbHVnaW4ocHJvZ3Jlc3MpIHtcbiAgY29uc3QgcHJvZ3Jlc3NDb21tYW5kID0gXCItLXByb2dyZXNzXCI7XG4gIGNvbnN0IHByb2dyZXNzTWV0aG9kcyA9IFtcImNoZWNrb3V0XCIsIFwiY2xvbmVcIiwgXCJmZXRjaFwiLCBcInB1bGxcIiwgXCJwdXNoXCJdO1xuICBjb25zdCBvblByb2dyZXNzID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYWZ0ZXJcIixcbiAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoIWNvbnRleHQuY29tbWFuZHMuaW5jbHVkZXMocHJvZ3Jlc3NDb21tYW5kKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoX2EyID0gY29udGV4dC5zcGF3bmVkLnN0ZGVycikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAvXihbXFxzXFxTXSs/KTpcXHMqKFxcZCspJSBcXCgoXFxkKylcXC8oXFxkKylcXCkvLmV4ZWMoY2h1bmsudG9TdHJpbmcoXCJ1dGY4XCIpKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2dyZXNzKHtcbiAgICAgICAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgICAgICAgIHN0YWdlOiBwcm9ncmVzc0V2ZW50U3RhZ2UobWVzc2FnZVsxXSksXG4gICAgICAgICAgcHJvZ3Jlc3M6IGFzTnVtYmVyKG1lc3NhZ2VbMl0pLFxuICAgICAgICAgIHByb2Nlc3NlZDogYXNOdW1iZXIobWVzc2FnZVszXSksXG4gICAgICAgICAgdG90YWw6IGFzTnVtYmVyKG1lc3NhZ2VbNF0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvbkFyZ3MgPSB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmICghcHJvZ3Jlc3NNZXRob2RzLmluY2x1ZGVzKGNvbnRleHQubWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmNsdWRpbmcoYXJncywgcHJvZ3Jlc3NDb21tYW5kKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBbb25BcmdzLCBvblByb2dyZXNzXTtcbn1cbmZ1bmN0aW9uIHByb2dyZXNzRXZlbnRTdGFnZShpbnB1dCkge1xuICByZXR1cm4gU3RyaW5nKGlucHV0LnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIgXCIsIDEpKSB8fCBcInVua25vd25cIjtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL3NwYXduLW9wdGlvbnMtcGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5mdW5jdGlvbiBzcGF3bk9wdGlvbnNQbHVnaW4oc3Bhd25PcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwaWNrKHNwYXduT3B0aW9ucywgW1widWlkXCIsIFwiZ2lkXCJdKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwYXduLm9wdGlvbnNcIixcbiAgICBhY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgZGF0YSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvdGltb3V0LXBsdWdpbi50c1xuZnVuY3Rpb24gdGltZW91dFBsdWdpbih7XG4gIGJsb2NrLFxuICBzdGRFcnIgPSB0cnVlLFxuICBzdGRPdXQgPSB0cnVlXG59KSB7XG4gIGlmIChibG9jayA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzcGF3bi5hZnRlclwiLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChraWxsLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICB2YXIgX2EzLCBfYjI7XG4gICAgICAgICAgKF9hMyA9IGNvbnRleHQuc3Bhd25lZC5zdGRvdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMub2ZmKFwiZGF0YVwiLCB3YWl0KTtcbiAgICAgICAgICAoX2IyID0gY29udGV4dC5zcGF3bmVkLnN0ZGVycikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5vZmYoXCJkYXRhXCIsIHdhaXQpO1xuICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vZmYoXCJleGl0XCIsIHN0b3ApO1xuICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vZmYoXCJjbG9zZVwiLCBzdG9wKTtcbiAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJ0aW1lb3V0XCIsIGBibG9jayB0aW1lb3V0IHJlYWNoZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RkT3V0ICYmICgoX2EyID0gY29udGV4dC5zcGF3bmVkLnN0ZG91dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vbihcImRhdGFcIiwgd2FpdCkpO1xuICAgICAgICBzdGRFcnIgJiYgKChfYiA9IGNvbnRleHQuc3Bhd25lZC5zdGRlcnIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vbihcImRhdGFcIiwgd2FpdCkpO1xuICAgICAgICBjb250ZXh0LnNwYXduZWQub24oXCJleGl0XCIsIHN0b3ApO1xuICAgICAgICBjb250ZXh0LnNwYXduZWQub24oXCJjbG9zZVwiLCBzdG9wKTtcbiAgICAgICAgd2FpdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4udHNcbmluaXRfcGF0aHNwZWMoKTtcbmZ1bmN0aW9uIHN1ZmZpeFBhdGhzUGx1Z2luKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYXJnc1wiLFxuICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBbXTtcbiAgICAgIGxldCBzdWZmaXg7XG4gICAgICBmdW5jdGlvbiBhcHBlbmQyKGFyZ3MpIHtcbiAgICAgICAgKHN1ZmZpeCA9IHN1ZmZpeCB8fCBbXSkucHVzaCguLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJhbSA9IGRhdGFbaV07XG4gICAgICAgIGlmIChpc1BhdGhTcGVjKHBhcmFtKSkge1xuICAgICAgICAgIGFwcGVuZDIodG9QYXRocyhwYXJhbSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbSA9PT0gXCItLVwiKSB7XG4gICAgICAgICAgYXBwZW5kMihcbiAgICAgICAgICAgIGRhdGEuc2xpY2UoaSArIDEpLmZsYXRNYXAoKGl0ZW0pID0+IGlzUGF0aFNwZWMoaXRlbSkgJiYgdG9QYXRocyhpdGVtKSB8fCBpdGVtKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4LnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFzdWZmaXggPyBwcmVmaXggOiBbLi4ucHJlZml4LCBcIi0tXCIsIC4uLnN1ZmZpeC5tYXAoU3RyaW5nKV07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2dpdC1mYWN0b3J5LnRzXG5pbml0X3V0aWxzKCk7XG52YXIgR2l0ID0gcmVxdWlyZV9naXQoKTtcbmZ1bmN0aW9uIGdpdEluc3RhbmNlRmFjdG9yeShiYXNlRGlyLCBvcHRpb25zKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IHBsdWdpbnMgPSBuZXcgUGx1Z2luU3RvcmUoKTtcbiAgY29uc3QgY29uZmlnID0gY3JlYXRlSW5zdGFuY2VDb25maWcoXG4gICAgYmFzZURpciAmJiAodHlwZW9mIGJhc2VEaXIgPT09IFwic3RyaW5nXCIgPyB7IGJhc2VEaXIgfSA6IGJhc2VEaXIpIHx8IHt9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgaWYgKCFmb2xkZXJFeGlzdHMoY29uZmlnLmJhc2VEaXIpKSB7XG4gICAgdGhyb3cgbmV3IEdpdENvbnN0cnVjdEVycm9yKFxuICAgICAgY29uZmlnLFxuICAgICAgYENhbm5vdCB1c2Ugc2ltcGxlLWdpdCBvbiBhIGRpcmVjdG9yeSB0aGF0IGRvZXMgbm90IGV4aXN0YFxuICAgICk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmNvbmZpZykpIHtcbiAgICBwbHVnaW5zLmFkZChjb21tYW5kQ29uZmlnUHJlZml4aW5nUGx1Z2luKGNvbmZpZy5jb25maWcpKTtcbiAgfVxuICBwbHVnaW5zLmFkZChibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oY29uZmlnLnVuc2FmZSkpO1xuICBwbHVnaW5zLmFkZChzdWZmaXhQYXRoc1BsdWdpbigpKTtcbiAgcGx1Z2lucy5hZGQoY29tcGxldGlvbkRldGVjdGlvblBsdWdpbihjb25maWcuY29tcGxldGlvbikpO1xuICBjb25maWcuYWJvcnQgJiYgcGx1Z2lucy5hZGQoYWJvcnRQbHVnaW4oY29uZmlnLmFib3J0KSk7XG4gIGNvbmZpZy5wcm9ncmVzcyAmJiBwbHVnaW5zLmFkZChwcm9ncmVzc01vbml0b3JQbHVnaW4oY29uZmlnLnByb2dyZXNzKSk7XG4gIGNvbmZpZy50aW1lb3V0ICYmIHBsdWdpbnMuYWRkKHRpbWVvdXRQbHVnaW4oY29uZmlnLnRpbWVvdXQpKTtcbiAgY29uZmlnLnNwYXduT3B0aW9ucyAmJiBwbHVnaW5zLmFkZChzcGF3bk9wdGlvbnNQbHVnaW4oY29uZmlnLnNwYXduT3B0aW9ucykpO1xuICBwbHVnaW5zLmFkZChlcnJvckRldGVjdGlvblBsdWdpbihlcnJvckRldGVjdGlvbkhhbmRsZXIodHJ1ZSkpKTtcbiAgY29uZmlnLmVycm9ycyAmJiBwbHVnaW5zLmFkZChlcnJvckRldGVjdGlvblBsdWdpbihjb25maWcuZXJyb3JzKSk7XG4gIGN1c3RvbUJpbmFyeVBsdWdpbihwbHVnaW5zLCBjb25maWcuYmluYXJ5LCAoX2EyID0gY29uZmlnLnVuc2FmZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5hbGxvd1Vuc2FmZUN1c3RvbUJpbmFyeSk7XG4gIHJldHVybiBuZXcgR2l0KGNvbmZpZywgcGx1Z2lucyk7XG59XG5cbi8vIHNyYy9saWIvcnVubmVycy9wcm9taXNlLXdyYXBwZWQudHNcbmluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG52YXIgZnVuY3Rpb25OYW1lc0J1aWxkZXJBcGkgPSBbXCJjdXN0b21CaW5hcnlcIiwgXCJlbnZcIiwgXCJvdXRwdXRIYW5kbGVyXCIsIFwic2lsZW50XCJdO1xudmFyIGZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpID0gW1xuICBcImFkZFwiLFxuICBcImFkZEFubm90YXRlZFRhZ1wiLFxuICBcImFkZENvbmZpZ1wiLFxuICBcImFkZFJlbW90ZVwiLFxuICBcImFkZFRhZ1wiLFxuICBcImFwcGx5UGF0Y2hcIixcbiAgXCJiaW5hcnlDYXRGaWxlXCIsXG4gIFwiYnJhbmNoXCIsXG4gIFwiYnJhbmNoTG9jYWxcIixcbiAgXCJjYXRGaWxlXCIsXG4gIFwiY2hlY2tJZ25vcmVcIixcbiAgXCJjaGVja0lzUmVwb1wiLFxuICBcImNoZWNrb3V0XCIsXG4gIFwiY2hlY2tvdXRCcmFuY2hcIixcbiAgXCJjaGVja291dExhdGVzdFRhZ1wiLFxuICBcImNoZWNrb3V0TG9jYWxCcmFuY2hcIixcbiAgXCJjbGVhblwiLFxuICBcImNsb25lXCIsXG4gIFwiY29tbWl0XCIsXG4gIFwiY3dkXCIsXG4gIFwiZGVsZXRlTG9jYWxCcmFuY2hcIixcbiAgXCJkZWxldGVMb2NhbEJyYW5jaGVzXCIsXG4gIFwiZGlmZlwiLFxuICBcImRpZmZTdW1tYXJ5XCIsXG4gIFwiZXhlY1wiLFxuICBcImZldGNoXCIsXG4gIFwiZ2V0UmVtb3Rlc1wiLFxuICBcImluaXRcIixcbiAgXCJsaXN0Q29uZmlnXCIsXG4gIFwibGlzdFJlbW90ZVwiLFxuICBcImxvZ1wiLFxuICBcIm1lcmdlXCIsXG4gIFwibWVyZ2VGcm9tVG9cIixcbiAgXCJtaXJyb3JcIixcbiAgXCJtdlwiLFxuICBcInB1bGxcIixcbiAgXCJwdXNoXCIsXG4gIFwicHVzaFRhZ3NcIixcbiAgXCJyYXdcIixcbiAgXCJyZWJhc2VcIixcbiAgXCJyZW1vdGVcIixcbiAgXCJyZW1vdmVSZW1vdGVcIixcbiAgXCJyZXNldFwiLFxuICBcInJldmVydFwiLFxuICBcInJldnBhcnNlXCIsXG4gIFwicm1cIixcbiAgXCJybUtlZXBMb2NhbFwiLFxuICBcInNob3dcIixcbiAgXCJzdGFzaFwiLFxuICBcInN0YXNoTGlzdFwiLFxuICBcInN0YXR1c1wiLFxuICBcInN1Yk1vZHVsZVwiLFxuICBcInN1Ym1vZHVsZUFkZFwiLFxuICBcInN1Ym1vZHVsZUluaXRcIixcbiAgXCJzdWJtb2R1bGVVcGRhdGVcIixcbiAgXCJ0YWdcIixcbiAgXCJ0YWdzXCIsXG4gIFwidXBkYXRlU2VydmVySW5mb1wiXG5dO1xuZnVuY3Rpb24gZ2l0UCguLi5hcmdzKSB7XG4gIGxldCBnaXQ7XG4gIGxldCBjaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0cnkge1xuICAgIGdpdCA9IGdpdEluc3RhbmNlRmFjdG9yeSguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNoYWluID0gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRlclJldHVybigpIHtcbiAgICByZXR1cm4gcHJvbWlzZUFwaTtcbiAgfVxuICBmdW5jdGlvbiBjaGFpblJldHVybigpIHtcbiAgICByZXR1cm4gY2hhaW47XG4gIH1cbiAgY29uc3QgcHJvbWlzZUFwaSA9IFsuLi5mdW5jdGlvbk5hbWVzQnVpbGRlckFwaSwgLi4uZnVuY3Rpb25OYW1lc1Byb21pc2VBcGldLnJlZHVjZShcbiAgICAoYXBpLCBuYW1lKSA9PiB7XG4gICAgICBjb25zdCBpc0FzeW5jID0gZnVuY3Rpb25OYW1lc1Byb21pc2VBcGkuaW5jbHVkZXMobmFtZSk7XG4gICAgICBjb25zdCB2YWxpZCA9IGlzQXN5bmMgPyBhc3luY1dyYXBwZXIobmFtZSwgZ2l0KSA6IHN5bmNXcmFwcGVyKG5hbWUsIGdpdCwgYXBpKTtcbiAgICAgIGNvbnN0IGFsdGVybmF0aXZlID0gaXNBc3luYyA/IGNoYWluUmV0dXJuIDogYnVpbGRlclJldHVybjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBnaXQgPyB2YWxpZCA6IGFsdGVybmF0aXZlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfSxcbiAgICB7fVxuICApO1xuICByZXR1cm4gcHJvbWlzZUFwaTtcbiAgZnVuY3Rpb24gYXN5bmNXcmFwcGVyKGZuLCBnaXQyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MyKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3MyW2FyZ3MyLmxlbmd0aF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiUHJvbWlzZSBpbnRlcmZhY2UgcmVxdWlyZXMgdGhhdCBoYW5kbGVycyBhcmUgbm90IHN1cHBsaWVkIGlubGluZSwgdHJhaWxpbmcgZnVuY3Rpb24gbm90IGFsbG93ZWQgaW4gY2FsbCB0byBcIiArIGZuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhaW4udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QodG9FcnJvcihlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGFyZ3MyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIGdpdDJbZm5dLmFwcGx5KGdpdDIsIGFyZ3MyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN5bmNXcmFwcGVyKGZuLCBnaXQyLCBhcGkpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MyKSA9PiB7XG4gICAgICBnaXQyW2ZuXSguLi5hcmdzMik7XG4gICAgICByZXR1cm4gYXBpO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHRvRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG4gIHJldHVybiBuZXcgR2l0UmVzcG9uc2VFcnJvcihlcnJvcik7XG59XG5cbi8vIHNyYy9lc20ubWpzXG52YXIgc2ltcGxlR2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5O1xudmFyIGVzbV9kZWZhdWx0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5O1xuZXhwb3J0IHtcbiAgQ2hlY2tSZXBvQWN0aW9ucyxcbiAgQ2xlYW5PcHRpb25zLFxuICBEaWZmTmFtZVN0YXR1cyxcbiAgR2l0Q29uZmlnU2NvcGUsXG4gIEdpdENvbnN0cnVjdEVycm9yLFxuICBHaXRFcnJvcixcbiAgR2l0UGx1Z2luRXJyb3IsXG4gIEdpdFJlc3BvbnNlRXJyb3IsXG4gIFJlc2V0TW9kZSxcbiAgVGFza0NvbmZpZ3VyYXRpb25FcnJvcixcbiAgZXNtX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2l0UCxcbiAgZ3JlcFF1ZXJ5QnVpbGRlcixcbiAgcGF0aHNwZWMsXG4gIHNpbXBsZUdpdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/simple-git/dist/esm/index.js\n");

/***/ })

};
;